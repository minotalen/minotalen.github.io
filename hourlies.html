<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hourlies</title>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        body {
            font-family: 'Atkinson Hyperlegible', sans-serif;
            background-color: #111827;
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        /* LAYOUT */
        .header {
            background-color: #1f2937;
            padding: env(safe-area-inset-top, 16px) 12% 12px 12%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            min-height: calc(48px + env(safe-area-inset-top, 16px));
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .main-container {
            height: calc(100vh - env(safe-area-inset-top, 16px) - 60px);
            position: relative;
            overflow-y: auto;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer and Edge */
            &::-webkit-scrollbar {
                display: none;  /* Chrome, Safari, and Opera */
            }
        }
        
        .settings-container, .daily-container {
            padding: 16px 12%;
            min-height: 100%;
        }
        
        .scroll-container {
            padding: 16px 0;
            margin: 0 12%;
            min-height: 100%;
            /* Hide default scrollbar */
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer and Edge */
            &::-webkit-scrollbar {
                display: none;  /* Chrome, Safari, and Opera */
            }
        }
        
        /* BUTTONS & INPUTS */
        .btn {
            background: none;
            border: none;
            color: #aeb6c3;
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
        }
        
        .btn:hover, .btn-active {
            color: white;
        }
        
        .btn-active {
            font-weight: 700;
        }
        
        input, select, textarea {
            background: none;
            border: none;
            color: #aeb6c3;
            font-family: inherit;
            transition: color 0.2s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            color: white;
        }
        
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        input[type=number] {
            -webkit-appearance: textfield;
        }
        
        textarea {
            color: #d1d5db;
            font-size: 20px;
        }       
        /* HEADER */
        .header h1 {
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 700;
            cursor: pointer;
            transition: color 0.2s;
            color: #aeb6c3;
            padding-top: 16px;
        }
        
        .header h1:hover {
            color: white;
        }
        
        .header-buttons {
            display: flex;
            gap: 1rem;
            align-items: center;
        }
        
        .btn-label {
            font-size: clamp(0.9rem, 2.5vw, 1.1rem);
            vertical-align: middle;
        }
        
        /* DATE NAVIGATION */
        .date-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .date-nav-left, .date-nav-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: #aeb6c3;
        }
        
        .date-input {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            text-align: center;
            width: clamp(120px, 30vw, 140px);
            cursor: pointer;
        }
        .date-btn {
            background-color: transparent;
            color: #6b7280;
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        .secondary-btn {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        
        .jump-btn {
            background-color: #1f2937;
            color: #6b7280;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        
        .jump-btn:hover {
            color: #d1d5db;
        }
        
        /* GOALS */
        .goals-section {
            margin-bottom: 16px;
            padding: 0px;
            background-color: transparent;
            border-radius: 8px;
        }
        
        .goals-title {
            font-weight: 600;
            color: #60a5fa;
            margin-bottom: 8px;
        }
        
        .goal-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
        }
        
        .goal-item.passed {
            background-color: #364e36;
        }
        
        .goal-item.failed {
            background-color: #5f3b3b;
            justify-content: flex-end;
            text-align: right;
        }
        
        .goal-text {
            color: #d1d5db;
            font-size: 1.6em;
            font-weight: 500;
        }
        
        .no-goals {
            padding: 8px 12px;
            border-radius: 4px;
            background-color: #2a313e;
            color: #6b7280;
            text-align: center;
            font-size: 14px;
        }
        
        /* HOURS */
        .hour-row {
            position: relative;
            margin-bottom: 8px;
        }
        
        .hour-entry {
            position: relative;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 4px;
            background-color: #343d4e;
            overflow: hidden;
            transition: all 0.2s;
        }
        
        .hour-entry:hover {
            background-color: #373e49;
        }
        
        .hour-entry.current {
            box-shadow: 0 0 0 2px #3b82f6;
        }
        
        .hour-entry.editing {
            box-shadow: 0 0 0 2px #3108ea;
            z-index: 40;
            user-select: text;
        }
        
        .hour-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #334870;
        }
        
        .hour-fill.empty {
            background-color: #1f242d;
        }
        
        .hour-content {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }
        
        .hour-time {
            font-size: 24px;
            width: 32px;
        }
        
        .hour-emojis {
            display: grid;
            grid-template-columns: repeat(2, 30px);
            gap: 4px;
            min-height: 30px;
            max-height: calc(30px * 3 + 8px);
            overflow: hidden;
            max-width: 64px;
            min-width: 64px;
            padding-right: 24px;
        }
        
        .hour-entry:not(.editing) .hour-content:has(.hour-text:empty) .hour-emojis {
            display: flex;
            flex-wrap: nowrap;
            gap: 4px;
            max-width: none;
            min-width: 0;
            overflow-x: auto;
        }
        
        .emoji {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            min-height: 28px;
        }
        
        .hour-input-container {
            flex: 1;
            display: flex;
            align-items: flex-start;
            position: relative;
        }
        
        .hour-input {
            flex: 1;
            background: transparent;
            color: #d1d5db;
            resize: none;
            overflow: hidden;
            min-height: 36px;
            line-height: 1.5;
            margin-top: 4px;
            transition: height 0.15s ease-out;
            user-select: text;
            white-space: pre-wrap;
        }
        
        .hour-input::placeholder {
            color: #6b7280;
        }
        
        .hour-input.empty {
            color: #6b7280;
        }
        
        .hour-input.scrolling {
            overflow-y: auto;
        }
        
        .hour-text {
            color: #d1d5db;
            font-size: 20px;
            white-space: pre-wrap;
        }
        
        .clear-btn {
            position: absolute;
            right: 0;
            top: 0;
            background: none;
            border: none;
            color: #eb6f6f;
            cursor: pointer;
            font-size: 28px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        /* EMOJI PICKER */
        .emoji-picker {
            position: absolute;
            left: 0;
            right: 0;
            background-color: #1f2937;
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, 48px);
            justify-content: center;
            gap: 8px;
            z-index: 50;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .emoji-picker.above {
            bottom: 100%;
            margin-bottom: 8px;
        }
        
        .emoji-picker.below {
            top: 100%;
            margin-top: 8px;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 90;
            backdrop-filter: blur(2px);
        }
        
        .emoji-btn {
            padding: 8px;
            font-size: 32px;
            background: none;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 4px;
        }
        
        .emoji-btn:hover {
            background-color: #373e49;
        }
        
        .emoji-btn.selected {
            background-color: #456090;
        }
        
        .emoji-btn.selected:hover {
            background-color: #1d4ed8;
        }
        
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 30;
        }
        
        /* SCROLL BAR */
        .scroll-bar {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 48px;
            cursor: ns-resize;
            transition: all 0.2s;
            background: repeating-linear-gradient(
                45deg,
                transparent 0px,
                transparent 3px,
                rgba(255,255,255,0.08) 3px,
                rgba(255,255,255,0.08) 4px,
                transparent 4px,
                transparent 8px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent 0px,
                transparent 3px,
                rgba(255,255,255,0.08) 3px,
                rgba(255,255,255,0.08) 4px,
                transparent 4px,
                transparent 8px
            );
        }
        
        .scroll-bar.hidden {
            display: none;
        }
        
        .scroll-bar.dragging {
            background-color: rgba(255, 255, 255, 0.1);
        }
        
        .hour-indicator {
            position: absolute;
            right: 8px;
            width: 0;
            height: 0;
            border-left: 6px solid #3b82f6;
            border-top: 3px solid transparent;
            border-bottom: 3px solid transparent;
            animation: pulse 2s infinite;
            pointer-events: none;
            transform: translateY(-50%);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* SETTINGS */
        .setting-group {
            margin-bottom: 24px;
        }
        
        .setting-label {
            display: block;
            color: #d1d5db;
            margin-bottom: 8px;
            font-size: 18px;
        }
        
        .setting-input {
            width: 100%;
            padding: 12px;
            background-color: #2a313e;
            color: white;
            border-radius: 4px;
            font-size: 18px;
            font-family: 'Atkinson Hyperlegible', monospace;
        }
        .emoji-input {
            font-size: 2.2em;
        }
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            cursor: pointer;
        }
        
        .checkbox {
            width: 20px;
            height: 20px;
        }
        
        .add-goal-btn, .export-btn {
            background-color: #334970;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .add-goal-btn:hover, .export-btn:hover {
            background-color: #173ca4;
        }
        
        /* GOAL EDITOR */
        .goal-row {
            position: relative;
            margin-bottom: 12px;
        }
        
        .goal-summary {
            cursor: pointer;
            padding: 12px;
            background-color: #2a313e;
            border-radius: 4px;
            transition: background-color 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 12px;
            min-width: 300px;
        }
        
        .goal-summary:hover {
            background-color: #373e49;
        }
        
        .goal-summary.editing {
            background-color: #1f2937;
            box-shadow: 0 0 0 2px #eab308;
        }
                
        .goal-text-display {
            color: #d1d5db;
            flex: 1;
            font-size: 18px;
        }
        
        .remove-goal-btn {
            background: none;
            border: none;
            color: #6b7280;
            cursor: pointer;
            font-size: 20px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .remove-goal-btn:hover {
            background-color: #374151;
            color: #ef4444;
        }
        
        .goal-editor {
            background-color: #1f2937;
            padding: 24px;
            border-radius: 8px;
            margin-top: 12px;
            border: 2px solid #eab308;
            position: relative;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .goal-editor-section {
            margin-bottom: 24px;
        }
        
        .goal-editor-section:last-child {
            margin-bottom: 0;
        }
        
        .goal-editor-label {
            color: #d1d5db;
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 12px;
            display: block;
        }
        
        .goal-emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, 56px);
            gap: 8px;
            max-height: 200px;
            overflow-y: auto;
            padding: 4px;
            background: #111827;
            border-radius: 8px;
        }
        
        .goal-emoji-btn {
            width: 56px;
            height: 56px;
            background: #2d3748;
            border: 2px solid transparent;
            border-radius: 8px;
            cursor: pointer;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }
        
        .goal-emoji-btn:hover {
            background: #374151;
            transform: scale(1.05);
        }
        
        .goal-emoji-btn.selected {
            border-color: #eab308;
            background: #1f2937;
        }
        
        .goal-emoji-btn:hover {
            background-color: #4b5563;
        }
        
        .goal-emoji-btn.selected {
            background-color: #3b82f6;
            border-color: #60a5fa;
        }
        
        .goal-controls-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
        }
        
        .operator-value-group {
            display: flex;
            gap: 8px;
            align-items: center;
        }
        
        .goal-operator-btn {
            background-color: #374151;
            color: #d1d5db;
            border: none;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s;
            font-size: 14px;
            min-width: 100px;
        }
        
        .goal-operator-btn {
            background-color: #2d3748;
            color: #e5e7eb;
            border: 2px solid transparent;
            padding: 10px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            min-width: 120px;
        }
        
        .goal-operator-btn:hover {
            background-color: #374151;
            border-color: #eab308;
        }
        
        .goal-value-input {
            width: 70px;
            text-align: center;
            background-color: #2d3748;
            color: #e5e7eb;
            border: 2px solid transparent;
            border-radius: 6px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            transition: all 0.2s;
        }
        
        .goal-value-input:hover,
        .goal-value-input:focus {
            background-color: #374151;
            border-color: #eab308;
            outline: none;
        }
        
        .goal-editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
        }
        
        .goal-action-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            background-color: #2d3748;
            color: #e5e7eb;
        }
        
        .goal-action-btn:hover {
            background-color: #374151;
            border-color: #eab308;
        }
        
        .operator-value-group {
            background: #111827;
            padding: 16px;
            border-radius: 8px;
            gap: 12px !important;
        }
        
        .goal-action-btn.secondary:hover {
            background-color: #4b5563;
        }
        
        /* EXPORT/IMPORT */
        .export-section {
            background-color: #2a313e;
            border-radius: 4px;
            overflow: hidden;
        }

        .export-toggle {
            width: 100%;
            background-color: #2a313e;
            color: white;
            border: none;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .export-toggle:hover {
            background-color: #373e49;
        }
        
        .export-arrow {
            transition: transform 0.2s;
        }
        
        .export-arrow.open {
            transform: rotate(180deg);
        }
        
        .export-content {
            padding: 12px;
            background-color: #2a313e;
        }
        
        .import-section {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .import-input {
            flex: 1;
            padding: 8px;
            background-color: #373e49;
            color: white;
            border-radius: 4px;
            font-size: 14px;
        }
        
        .export-help {
            font-size: 12px;
            color: #aeb6c3;
            padding-top: 8px;
            border-top: 1px solid #373e49;
        }
        
        /* DAILY VIEW */
        .bubbles-container {
            border-radius: 8px;
            height: 350px;
            position: relative;
            overflow: hidden;
            border: 1px solid #2a313e;
            margin-bottom: 24px;
        }
        
        .bubble {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: white;
            background-color: #1F2937;
            font-size: 40px;
        }
        
        .dailies-section h3 {
            font-size: 18px;
            font-weight: 600;
            color: white;
            margin-bottom: 12px;
        }
        
        .no-goals-daily {
            color: #6b7280;
            font-size: 14px;
        }
        
        /* ANIMATIONS */
        @keyframes flash-border {
            0% { box-shadow: 0 0 0 2px white; }
            100% { box-shadow: none; }
        }
        
        .hour-entry.flash {
            animation: flash-border 0.5s ease;
        }
        
        /* MOBILE */
        @media (max-width: 768px) {
            .scroll-bar { display: none !important; }
            .header { 
                padding: calc(env(safe-area-inset-top, 12px) + 8px) 16px 8px 16px;
                min-height: calc(44px + env(safe-area-inset-top, 12px));
            }
            .settings-container, .daily-container { 
                padding: 8px 16px;
                padding-top: calc(env(safe-area-inset-top, 12px) + 60px);
            }
            .scroll-container { 
                padding: 8px 0; 
                margin: 0 16px;
            }
            .header h1 { font-size: 1.4em; }
            .btn { font-size: 1.3em !important; }
            .btn-label { font-size: 0.6em; }
            .date-nav { margin-bottom: 12px; }
            .secondary-btn, .date-input { font-size: 22px; }
            .date-input { width: 140px; }
            .hour-time { font-size: 20px; width: 28px; }
            .hour-emojis { grid-template-columns: repeat(2, 26px); gap: 2px; max-width: 54px; min-width: 54px; }
            .emoji { font-size: 24px; min-height: 24px; }
            .hour-text, .hour-input { font-size: 16px; }
            .emoji-picker { grid-template-columns: repeat(auto-fit, 42px); gap: 4px; padding: 8px; }
            .emoji-btn { width: 42px; height: 42px; font-size: 28px; }
            .setting-label, .setting-input, .checkbox-label { font-size: 16px; }
            .setting-input { padding: 10px; }
            .checkbox { width: 18px; height: 18px; }
            .bubble { font-size: 32px !important; }
            .dailies-section h3 { font-size: 16px; }
            .goal-text-display { font-size: 16px; }
        }
        
        @media (max-width: 375px) {
            .header { 
                padding: env(safe-area-inset-top, 12px) 12px 6px 12px;
                min-height: calc(48px + env(safe-area-inset-top, 12px));
            }
            .header h1 { font-size: 1.2em; }
            .btn { font-size: 1.2em !important; }
            .btn-label { font-size: 0.55em; }
            .settings-container, .daily-container { padding: 8px 12px; }
            .scroll-container { padding: 8px 0; margin: 0 12px; }
            .hour-time { font-size: 18px; width: 24px; }
            .hour-emojis { grid-template-columns: repeat(2, 24px); max-width: 50px; min-width: 50px; }
            .emoji { font-size: 22px; min-height: 22px; }
            .hour-text, .hour-input { font-size: 16px; }
            .emoji-picker { grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 6px; }
            .emoji-btn { padding: 4px; font-size: 24px; }
            .date-input, .secondary-btn { font-size: 18px; }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <div style="display: flex; align-items: center; gap: 16px;">
                <h1><div class="btn-active" id="floatingNavDate">hourlies</div></h1>
                <button class="btn" onclick="app.undo()" id="undoBtn" style="display: none;">↶</button>
            </div>
            <div class="header-buttons">
                <button class="btn" onclick="app.setView('daily')" title="Press 'D'">🎯 <span class="btn-label">daily</span></button>
                <button class="btn" onclick="app.setView('settings')" title="Press 'E'">⚙ <span class="btn-label">edit</span></button>
            </div>
        </div>
        <div class="main-container" id="mainContainer"></div>
    </div>

    <script>
        class HourliesApp {

            constructor() {
                this.currentTime = new Date();
                this.startHour = 7;
                this.allEntries = {};
                this.goals = [];
                this.emojis = ['☕', '📖', '😴', '🎮', '🍕', '💊', '🌿', '🔴', '🟩', '📷'];
                this.showGoalsInTimeline = false;
                
                this.currentDate = new Date();
                this.editingHour = null;
                this.editingGoal = null;
                this.view = 'timeline';
                this.undoStack = [];
                this.clipboardEntry = null;
                this.timelineScrollPosition = 0;
                this.hoveredHour = null; // Track which hour entry is currently being hovered

                this.loadData();
                this.currentDate = this.getEffectiveDate();
                this.render();
                this.startTimer();
                this.setupEvents();
                setTimeout(() => this.scrollToCurrentHour(), 100);
            }

            // === DATA ===
            loadData() {
                const saved = localStorage.getItem("hourliesData");
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        Object.assign(this, {
                            allEntries: data.allEntries || {},
                            goals: data.goals || [],
                            emojis: data.emojis || this.emojis,
                            startHour: data.startHour ?? this.startHour,
                            showGoalsInTimeline: data.showGoalsInTimeline ?? false
                        });
                    } catch (e) {
                        console.warn("Failed to load saved data", e);
                    }
                } else {
                    this.createWelcomeMessage();
                }
            }

            createWelcomeMessage() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                const welcomeEntries = {
                    7: { emojis: ['👋'], text: 'welcome to hourlies' },
                    8: { emojis: ['📊'], text: 'track your daily activities with emojis and text' },
                    10: { emojis: ['✏️'], text: 'click any hour to add what you did or plan to do' },
                    12: { emojis: ['📄'], text: isMobile ? 'long tap to copy filled hour' : 'right click to copy filled hour' },
                    13: { emojis: ['📋'], text: 'repeat on empty hour to paste' },
                    15: { emojis: ['⚙️'], text: 'go to edit to customize emojis and dailies' },
                    16: { emojis: ['🎯'], text: 'dailies are simple rules for tracking habits' },
                    18: { emojis: ['🏠'], text: 'daily view shows your patterns visually' },
                    19: { emojis: ['🗑️'], text: 'wipe current day there to start fresh' },
                    21: { emojis: ['📄'], text: isMobile ? '' : 'you can use your keyboard to jump between entries' },
                };
                this.allEntries[this.currentDateKey] = welcomeEntries;

                // Add default rules if none exist
                if (!this.goals || this.goals.length === 0) {
                    this.goals = [
                        { id: Date.now() + 1, emoji: '☕', operator: 'after', value: 17, not: true }, // no coffee after 17
                        { id: Date.now() + 2, emoji: '☕', operator: 'more_than', value: 3 }, // no more than 3 coffee
                        { id: Date.now() + 3, emoji: '😴', operator: 'before', value: 0 } // sleep before 00
                    ];
                }
            }

            saveData() {
                localStorage.setItem("hourliesData", JSON.stringify({
                    allEntries: this.allEntries,
                    goals: this.goals,
                    emojis: this.emojis,
                    startHour: this.startHour,
                    showGoalsInTimeline: this.showGoalsInTimeline
                }));
            }

            updateEntries(newEntries) {
                this.undoStack.push({ 
                    entries: { ...this.entries }, 
                    timestamp: Date.now(),
                    date: new Date(this.currentDate) // Store the date for undo
                });
                if (this.undoStack.length > 100) this.undoStack.shift();
                
                // Split entries into correct calendar days
                const currentDayKey = this.dateKey(this.currentDate);
                const nextDay = new Date(this.currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                
                // Initialize storage objects
                if (!this.allEntries[currentDayKey]) this.allEntries[currentDayKey] = {};
                if (!this.allEntries[nextDayKey]) this.allEntries[nextDayKey] = {};
                
                // Store entries in correct calendar days
                Object.entries(newEntries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        // Hours 7-23 go to current calendar day
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        // Hours 0-6 go to next calendar day
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });
                
                this.updateUndoButton();
                this.saveData();
            }

            // === UTILITIES ===
            dateKey(date) { return date ? date.toISOString().split('T')[0] : ''; }
            
            get currentDateKey() { 
                // For data storage, we need to account for hours that belong to previous day
                const effectiveDate = new Date(this.currentDate);
                return this.dateKey(effectiveDate);
            }
            
            get entries() { 
                // Get entries for the current logical day
                const currentDayEntries = this.allEntries[this.currentDateKey] || {};
                const nextDay = new Date(this.currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                const nextDayEntries = this.allEntries[nextDayKey] || {};
                
                // Combine entries: hours 0-6 from next calendar day + hours 7-23 from current day
                const combinedEntries = {};
                
                // Add hours 7-23 from current calendar day
                for (let hour = this.startHour; hour < 24; hour++) {
                    if (currentDayEntries[hour]) {
                        combinedEntries[hour] = currentDayEntries[hour];
                    }
                }
                
                // Add hours 0-(startHour-1) from next calendar day
                for (let hour = 0; hour < this.startHour; hour++) {
                    if (nextDayEntries[hour]) {
                        combinedEntries[hour] = nextDayEntries[hour];
                    }
                }
                
                return combinedEntries;
            }
            
            get hours() { return Array.from({length: 24}, (_, i) => (this.startHour + i) % 24); }
            formatHour(hour) { return hour.toString().padStart(2, '0'); }
            
            formatDateInput() {
                if (!this.currentDate) return '';
                return [
                    this.currentDate.getDate().toString().padStart(2, '0'),
                    (this.currentDate.getMonth() + 1).toString().padStart(2, '0'),
                    this.currentDate.getFullYear().toString().slice(-2)
                ].join('/');
            }

            getEffectiveDate() {
                // Get the current logical day based on start hour
                const d = new Date(this.currentTime);
                if (d.getHours() < this.startHour) {
                    d.setDate(d.getDate() - 1);
                }
                return d;
            }

            isCurrentDate() { return this.dateKey(this.getEffectiveDate()) === this.currentDateKey; }
            isPastDate() { return this.dateKey(this.currentDate) < this.dateKey(this.getEffectiveDate()); }
            isFutureDate() { return this.dateKey(this.currentDate) > this.dateKey(this.getEffectiveDate()); }

            getHourFill(hour) {
                if (this.isFutureDate()) return 0;
                if (this.isPastDate()) return 100;
                if (!this.isCurrentDate()) return 0;
                
                const currentHour = this.currentTime.getHours();
                const adjustedHour = hour < this.startHour ? hour + 24 : hour;
                const adjustedCurrentHour = currentHour < this.startHour ? currentHour + 24 : currentHour;
                
                if (adjustedHour < adjustedCurrentHour) return 100;
                if (adjustedHour === adjustedCurrentHour) return (this.currentTime.getMinutes() / 60) * 100;
                return 0;
            }

            isCurrentHour(hour) {
                return this.isCurrentDate() && this.currentTime.getHours() === hour;
            }

            // === EVENTS ===
            setupEvents() {
                // Global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in input fields
                    if (e.target.matches('input, textarea')) return;
                    
                    // Don't trigger when editing an hour
                    if (this.editingHour !== null) return;
                    
                    switch (e.key.toLowerCase()) {
                        case 'arrowleft':
                            this.navigateDay(-1);
                            e.preventDefault();
                            break;
                        case 'arrowright':
                            this.navigateDay(1);
                            e.preventDefault();
                            break;
                        case 'f':
                            document.querySelector('.date-input')?.focus();
                            e.preventDefault();
                            break;
                        case 'e':
                            this.setView('settings');
                            e.preventDefault();
                            break;
                        case 'd':
                            this.setView('daily');
                            e.preventDefault();
                            break;
                        case 'h':
                            this.setView('timeline');
                            e.preventDefault();
                            break;
                    }
                });
                
                // Handle backspace/delete on hover
                document.addEventListener('keydown', (e) => {
                    if ((e.key === 'Backspace' || e.key === 'Delete') && 
                        this.editingHour === null && // Not in edit mode
                        this.hoveredHour !== null && // Hovering over an entry
                        this.view === 'timeline' && // In timeline view
                        !e.target.matches('input, textarea')) { // Not typing in an input
                        this.clearEntry(this.hoveredHour);
                        e.preventDefault(); // Prevent browser back navigation
                    }
                });

                document.addEventListener('click', (e) => {
                    if (this.editingHour === null) return;
                    const isInterface = e.target.classList.contains('overlay') ||
                                      e.target.classList.contains('hour-input') ||
                                      e.target.classList.contains('clear-btn') ||
                                      e.target.classList.contains('emoji-btn');
                    if (!isInterface) {
                        e.preventDefault();
                        setTimeout(() => {
                            const textarea = document.querySelector(`[data-hour="${this.editingHour}"] textarea`);
                            if (textarea) {
                                textarea.focus();
                                textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                            }
                        }, 0);
                    }
                });
            }

            // === NAVIGATION ===
            navigateDay(direction) {
                this.currentDate.setDate(this.currentDate.getDate() + direction);
                this.editingHour = null;
                this.render();
            }

            jumpToToday() {
                this.currentDate = this.getEffectiveDate();
                this.editingHour = null;
                this.render();
                setTimeout(() => this.scrollToCurrentHour(), 100);
            }

            setView(view) {
                if (this.view === 'timeline' && view !== 'timeline') {
                    const container = document.querySelector('.daily-container');
                    if (container) this.timelineScrollPosition = container.scrollTop;
                }

                this.view = view;
                this.editingHour = null;
                this.editingGoal = null;
                this.updateHeaderTitle();
                this.render();
            }

            updateHeaderTitle() {
                const floatingNavDate = document.getElementById('floatingNavDate');
                if (!floatingNavDate) return;

                if (this.view === 'timeline') {
                    floatingNavDate.textContent = "hourlies";
                    floatingNavDate.classList.add('btn-active');
                } else {
                    floatingNavDate.textContent = "← " + this.formatNavbarDate(this.currentDate).toLowerCase();
                    floatingNavDate.classList.remove('btn-active');
                }
            }

            handleScroll(e) {
                const scrolled = e.target.scrollTop > 150;
                const floatingNavDate = document.getElementById('floatingNavDate');
                
                if (floatingNavDate) {
                    if (this.view === 'timeline') {
                        if (scrolled) {
                            floatingNavDate.textContent = this.formatNavbarDate(this.currentDate).toLowerCase();
                            floatingNavDate.onclick = () => {
                                document.getElementById('mainContainer').scrollTo({ top: 0, behavior: 'smooth' });
                            };
                        } else {
                            floatingNavDate.textContent = "hourlies";
                            floatingNavDate.onclick = () => app.setView('timeline');
                        }
                        floatingNavDate.classList.add('btn-active');
                    } else {
                        floatingNavDate.textContent = "← " + this.formatNavbarDate(this.currentDate).toLowerCase();
                        floatingNavDate.onclick = () => app.setView('timeline');
                        floatingNavDate.classList.remove('btn-active');
                    }
                }
            }

            // === DATE INPUT ===
            handleDateInput(event) {
                const value = event.target.value.replace(/\D/g, '');
                event.target.value = value.match(/.{1,2}/g)?.join('/') || value;

                const parseAndSetDate = (value, useCurrentYear = false) => {
                    const day = parseInt(value.slice(0, 2), 10);
                    const month = parseInt(value.slice(2, 4), 10) - 1;
                    const year = useCurrentYear ? this.currentTime.getFullYear() : 2000 + parseInt(value.slice(4, 6), 10);

                    // Set currentDate and currentTime to the user's entered date
                    const inputDate = new Date(year, month, day, 12, 0, 0);

                    if (!isNaN(inputDate.getTime()) && day > 0 && day <= 31 && month >= 0 && month < 12) {
                        this.currentDate = new Date(year, month, day);
                        this.currentTime = new Date(year, month, day, 12, 0, 0);
                        event.target.value = this.formatDateInput();
                        this.render();
                        return true;
                    }
                    return false;
                };

                if (value.length === 4 && (event.type === 'blur' || event.key === 'Enter')) {
                    if (!parseAndSetDate(value, true)) {
                        event.target.value = this.formatDateInput();
                    }
                } else if (value.length === 6) {
                    parseAndSetDate(value);
                }
            }

            formatNavbarDate(date) {
                return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }).toLowerCase();
            }

            handleDateKeydown(event) {
                const allowed = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Escape'];
                if (!/^\d$/.test(event.key) && !allowed.includes(event.key)) {
                    event.preventDefault();
                }
                if (event.key === 'Enter') {
                    event.preventDefault();
                    event.target.blur();
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    event.target.value = this.formatDateInput();
                    event.target.blur();
                }
            }

            handleDateFocus(event) {
                event.target.select();
                event.target.addEventListener('blur', (e) => this.handleDateInput(e), { once: true });
            }

            // === HOURS ===
            editHour(hour) {
                if (this.editingHour === hour) return;
                this.editingHour = hour;
                this.renderHours();
                
                setTimeout(() => {
                    const hourElement = document.querySelector(`[data-hour="${hour}"]`);
                    const textarea = hourElement?.querySelector('textarea');
                    if (textarea) {
                        if (window.innerWidth <= 768) {
                            const container = document.querySelector('.scroll-container');
                            const containerRect = container.getBoundingClientRect();
                            const elementRect = hourElement.getBoundingClientRect();
                            const relativeTop = elementRect.top - containerRect.top;
                            const targetPosition = containerRect.height * 0.15;
                            container.scrollTop = container.scrollTop + (relativeTop - targetPosition);
                        } else {
                            hourElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        
                        setTimeout(() => {
                            textarea.focus();
                            textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                        }, 100);
                    }
                }, 30);
            }

            updateText(text) {
                const entry = this.entries[this.editingHour] || { emojis: [], text: '' };
                const newEntries = { ...this.entries };
                newEntries[this.editingHour] = { ...entry, text };
                
                this.undoStack.push({ 
                    entries: { ...this.entries }, 
                    timestamp: Date.now(),
                    date: new Date(this.currentDate)
                });
                if (this.undoStack.length > 50) this.undoStack.shift();
                this.allEntries[this.currentDateKey] = newEntries;
                this.updateUndoButton();
                this.saveData();
            }

            clearEntry(hour) {
                const newEntries = { ...this.entries };
                newEntries[hour] = { emojis: [], text: '' };
                this.updateEntries(newEntries);
                this.editingHour = null;
                this.renderHours();
            }

            toggleEmoji(emoji) {
                const entry = this.entries[this.editingHour] || { emojis: [], text: '' };
                const validEmojis = entry.emojis.filter(e => this.emojis.includes(e));
                const newEmojis = validEmojis.includes(emoji)
                    ? validEmojis.filter(e => e !== emoji)
                    : [...validEmojis, emoji];
                const newEntries = { ...this.entries };
                newEntries[this.editingHour] = { ...entry, emojis: newEmojis };
                this.updateEntries(newEntries);
                this.renderHours();
                this.renderGoals();
                setTimeout(() => {
                    const textarea = document.querySelector(`[data-hour="${this.editingHour}"] textarea`);
                    if (textarea) {
                        textarea.focus();
                        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                    }
                }, 50);
            }

            handleHourInputKeydown(event, hour) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.editingHour = null;
                    this.renderHours();
                } else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    const textarea = event.target;
                    const cursorAtEnd = textarea.selectionStart === textarea.value.length;
                    
                    // Only navigate if cursor is at the very end of the text
                    if (cursorAtEnd) {
                        event.preventDefault();
                        const currentIndex = this.hours.indexOf(hour);
                        const nextIndex = event.key === 'ArrowUp' 
                            ? (currentIndex - 1 + this.hours.length) % this.hours.length
                            : (currentIndex + 1) % this.hours.length;
                        const nextHour = this.hours[nextIndex];

                        this.editingHour = nextHour;
                        this.renderHours();
                        
                        setTimeout(() => {
                            const nextTextarea = document.querySelector(`[data-hour="${nextHour}"] textarea`);
                            if (nextTextarea) {
                                nextTextarea.focus();
                                nextTextarea.selectionStart = nextTextarea.selectionEnd = nextTextarea.value.length;
                            }
                        }, 0);
                    }
                }
            }

            // === COPY/PASTE ===
            handleCopyPaste(hour, entry, element) {
                const hasContent = (entry.text && entry.text.trim()) || (entry.emojis && entry.emojis.length > 0);

                if (hasContent) {
                    this.clipboardEntry = {
                        emojis: entry.emojis ? [...entry.emojis] : [],
                        text: entry.text || ""
                    };
                    element.classList.add("flash");
                    setTimeout(() => element.classList.remove("flash"), 500);
                } else if (this.clipboardEntry) {
                    const newEntries = { ...this.entries };
                    newEntries[hour] = { ...this.clipboardEntry };
                    this.updateEntries(newEntries);
                    this.renderHours();
                }
            }

            attachCopyPasteEvents() {
                document.querySelectorAll(".hour-entry").forEach(el => {
                    const hour = parseInt(el.dataset.hour);
                    const entry = this.entries[hour] || { emojis: [], text: "" };

                    el.addEventListener("mouseenter", () => {
                        this.hoveredHour = hour;
                    });

                    el.addEventListener("mouseleave", () => {
                        this.hoveredHour = null;
                    });

                    el.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        this.handleCopyPaste(hour, entry, el);
                    });

                    let longPressTimer;
                    el.addEventListener("touchstart", () => {
                        longPressTimer = setTimeout(() => {
                            this.handleCopyPaste(hour, entry, el);
                            el._suppressClick = true;
                        }, 500);
                    });
                    
                    el.addEventListener("touchend", () => clearTimeout(longPressTimer));
                    el.addEventListener("touchmove", () => clearTimeout(longPressTimer));

                    el.addEventListener("click", (e) => {
                        if (el._suppressClick) {
                            e.stopImmediatePropagation();
                            el._suppressClick = false;
                        }
                    }, true);
                });
            }

            // === GOALS ===
            addGoal() {
                const newGoal = {
                    id: Date.now(),
                    emojis: ['📖'],
                    operator: 'more_than',
                    value: 1
                };
                this.goals.push(newGoal);
                this.renderSettings();
            }

            updateGoal(id, updates) {
                this.goals = this.goals.map(goal => goal.id === id ? { ...goal, ...updates } : goal);
                this.saveData();
                this.renderSettings();
            }

            removeGoal(id) {
                this.goals = this.goals.filter(goal => goal.id !== id);
                this.saveData();
                this.renderSettings();
            }

            editGoal(id) {
                this.editingGoal = this.editingGoal === id ? null : id;
                this.renderSettings();
            }

            cycleOperator(goalId) {
                const goal = this.goals.find(g => g.id === goalId);
                const operators = ['more_than', 'less_than', 'before', 'after'];
                const currentIndex = operators.indexOf(goal.operator);
                const nextIndex = (currentIndex + 1) % operators.length;
                this.updateGoal(goalId, { operator: operators[nextIndex] });
            }

            formatGoalText(goal) {
                const opText = goal.operator.replace('_', ' ');
                const suffix = goal.operator.includes('than') ? ' times' : '';
                const negation = goal.not ? 'not ' : '';
                const emojiText = Array.isArray(goal.emojis) ? goal.emojis.join(' ') : goal.emoji;
                return `${negation}${emojiText} ${opText} ${goal.value}${suffix}`;
            }

            checkGoals() {
                const dayEntries = Object.values(this.entries);
                return this.goals.map(goal => {
                    const emojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                    // Count total appearances of any emoji in the rule
                    const emojiCount = dayEntries.reduce((count, entry) => {
                        return count + emojis.reduce((c, emoji) => c + (entry.emojis?.filter(e => e === emoji).length || 0), 0);
                    }, 0);
                    // Find all hours where any emoji in the rule appears
                    const emojiHours = Object.keys(this.entries).filter(hour => {
                        const entryEmojis = this.entries[hour].emojis || [];
                        return emojis.some(emoji => entryEmojis.includes(emoji));
                    }).map(Number);
                    let met = false;
                    if (goal.operator === 'more_than') {
                        met = emojiCount > goal.value;
                    } else if (goal.operator === 'less_than') {
                        met = emojiCount < goal.value;
                    } else if (goal.operator === 'before' && emojiHours.length > 0) {
                        const adjustedHours = emojiHours.map(h => h < this.startHour ? h + 24 : h);
                        const adjustedTarget = goal.value < this.startHour ? goal.value + 24 : goal.value;
                        met = Math.min(...adjustedHours) < adjustedTarget;
                    } else if (goal.operator === 'after' && emojiHours.length > 0) {
                        const adjustedHours = emojiHours.map(h => h < this.startHour ? h + 24 : h);
                        const adjustedTarget = goal.value < this.startHour ? goal.value + 24 : goal.value;
                        met = Math.max(...adjustedHours) > adjustedTarget;
                    }
                    if (goal.not) met = !met;
                    return { ...goal, met, emojiCount };
                });
            }

            // === TIMER ===
            startTimer() {
                setInterval(() => {
                    this.currentTime = new Date();
                    const effectiveDate = this.getEffectiveDate();
                    if (this.dateKey(effectiveDate) !== this.currentDateKey) {
                        this.currentDate = effectiveDate;
                    }
                    if (this.view === 'timeline' && this.editingHour === null) {
                        this.renderHours();
                    }
                }, 60000);
            }

            undo() {
                if (this.undoStack.length === 0) return;
                const lastState = this.undoStack.pop();
                
                // Restore the date from the undo state
                if (lastState.date) {
                    this.currentDate = new Date(lastState.date);
                }
                
                // Apply the undo state using the same logic as updateEntries
                const currentDayKey = this.dateKey(this.currentDate);
                const nextDay = new Date(this.currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                
                // Clear current entries
                if (this.allEntries[currentDayKey]) {
                    for (let hour = this.startHour; hour < 24; hour++) {
                        delete this.allEntries[currentDayKey][hour];
                    }
                }
                if (this.allEntries[nextDayKey]) {
                    for (let hour = 0; hour < this.startHour; hour++) {
                        delete this.allEntries[nextDayKey][hour];
                    }
                }
                
                // Restore entries
                Object.entries(lastState.entries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        if (!this.allEntries[currentDayKey]) this.allEntries[currentDayKey] = {};
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        if (!this.allEntries[nextDayKey]) this.allEntries[nextDayKey] = {};
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });
                
                this.updateUndoButton();
                this.renderHours();
                this.saveData();
            }

            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.style.display = this.view === 'timeline' && this.undoStack.length > 0 ? 'block' : 'none';
                }
            }

            scrollToCurrentHour() {
                const container = document.querySelector('.scroll-container');
                if (!container) return;
                const currentHourIndex = this.hours.findIndex(hour => hour === this.currentTime.getHours());
                if (currentHourIndex === -1) return;
                const hourElements = container.querySelectorAll('[data-hour]');
                const targetElement = hourElements[currentHourIndex];
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            // === EXPORT ===
            exportCurrentDayCSV() {
                let content = "";
                this.hours.forEach(hour => {
                    const entry = this.entries[hour];
                    const emojis = entry?.emojis?.join('') || '';
                    const text = entry?.text || '';
                    content += `${emojis} ${text}\n`;
                });
                
                try {
                    navigator.clipboard.writeText(content);
                } catch (err) {
                    const blob = new Blob([content], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hourlies-${this.formatDateInput()}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            groupEntriesByMonth() {
                const months = {};
                Object.entries(this.allEntries).forEach(([dateKey, entries]) => {
                    const [year, month] = dateKey.split('-');
                    const monthKey = `${year}-${month}`;
                    if (!months[monthKey]) months[monthKey] = {};
                    months[monthKey][dateKey] = entries;
                });
                return months;
            }

            exportAllToCSV() {
                const monthlyData = this.groupEntriesByMonth();
                const settings = {
                    version: 1,
                    timestamp: new Date().toISOString(),
                    settings: {
                        emojis: this.emojis,
                        startHour: this.startHour,
                        showGoalsInTimeline: this.showGoalsInTimeline
                    },
                    rules: this.goals.map(goal => ({
                        ...goal,
                        emojis: Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji]
                    }))
                };

                // Create a settings file
                const settingsBlob = new Blob([JSON.stringify(settings, null, 2)], { type: 'application/json' });
                const settingsUrl = URL.createObjectURL(settingsBlob);
                const settingsLink = document.createElement('a');
                settingsLink.href = settingsUrl;
                settingsLink.download = 'hourlies-settings.json';
                document.body.appendChild(settingsLink);
                settingsLink.click();
                document.body.removeChild(settingsLink);
                URL.revokeObjectURL(settingsUrl);

                // Create CSV files for each month
                Object.entries(monthlyData).forEach(([monthKey, monthEntries]) => {
                    const [year, month] = monthKey.split('-');
                    const dates = Object.keys(monthEntries).sort();
                    const hours = Array.from({ length: 24 }, (_, i) => (this.startHour + i) % 24);

                    // Create CSV content
                    let csvContent = 'Date,' + hours.map(h => h.toString().padStart(2, '0')).join(',') + '\n';
                    dates.forEach(date => {
                        const dayEntries = monthEntries[date];
                        const row = [date];
                        hours.forEach(hour => {
                            const entry = dayEntries[hour];
                            const cellContent = entry ? (entry.emojis?.join('') || '') + ' ' + (entry.text || '') : '';
                            row.push(this.escapeCSV(cellContent));
                        });
                        csvContent += row.join(',') + '\n';
                    });

                    const blob = new Blob([csvContent], { type: 'text/csv' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hourlies-${monthKey}.csv`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                });
            }

            escapeCSV(str) {
                if (!str) return '';
                str = str.replace(/"/g, '""');
                if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                    str = `"${str}"`;
                }
                return str;
            }

            importFromCSVFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.name.endsWith('.json')) {
                        // Import settings file
                        try {
                            const importData = JSON.parse(e.target.result);
                            console.log('Importing settings:', importData);  // Debug log
                            
                            // Handle both old and new format
                            if (importData.version === 1) {
                                // New format
                                if (importData.settings) {
                                    if (Array.isArray(importData.settings.emojis)) {
                                        this.emojis = [...importData.settings.emojis];
                                    }
                                    if (typeof importData.settings.startHour === 'number' && 
                                        importData.settings.startHour >= 0 && 
                                        importData.settings.startHour < 24) {
                                        this.startHour = importData.settings.startHour;
                                    }
                                    if (typeof importData.settings.showGoalsInTimeline === 'boolean') {
                                        this.showGoalsInTimeline = Boolean(importData.settings.showGoalsInTimeline);
                                    }
                                }
                                if (Array.isArray(importData.rules)) {
                                    // Ensure all goals have required properties and valid values
                                    this.goals = importData.rules.filter(goal => {
                                        const validOperators = ['more_than', 'less_than', 'before', 'after'];
                                        return goal && 
                                               goal.id && 
                                               Array.isArray(goal.emojis) && 
                                               validOperators.includes(goal.operator) && 
                                               typeof goal.value === 'number';
                                    }).map(goal => ({
                                        ...goal,
                                        not: Boolean(goal.not),
                                        value: Math.max(0, Math.min(23, goal.value))  // Clamp value between 0-23
                                    }));
                                }
                            } else {
                                // Old format for backward compatibility
                                if (Array.isArray(importData.emojis)) {
                                    this.emojis = [...importData.emojis].filter(emoji => /\p{Emoji}/u.test(emoji));
                                }
                                if (Array.isArray(importData.goals)) {
                                    this.goals = importData.goals.map(goal => {
                                        if (goal.emoji && !goal.emojis) {
                                            goal.emojis = [goal.emoji];
                                            delete goal.emoji;
                                        }
                                        return goal;
                                    });
                                }
                                if (typeof importData.startHour === 'number' && 
                                    importData.startHour >= 0 && 
                                    importData.startHour < 24) {
                                    this.startHour = importData.startHour;
                                }
                                if (typeof importData.showGoalsInTimeline === 'boolean') {
                                    this.showGoalsInTimeline = Boolean(importData.showGoalsInTimeline);
                                }
                            }
                            this.saveData();
                            this.render();
                            alert('Settings imported successfully');
                        } catch (err) {
                            alert('Error importing settings: Invalid JSON file');
                        }
                    } else if (file.name.endsWith('.csv')) {
                        // Import CSV data file
                        try {
                            const lines = e.target.result.split(/\r?\n/);
                            const headers = this.parseCSVLine(lines[0]);
                            console.log('CSV headers:', headers);  // Debug log
                            if (!headers[0].toLowerCase().includes('date')) {
                                throw new Error('Invalid CSV format: first column must be Date');
                            }
                            const hours = headers.slice(1).map(h => {
                                const hour = parseInt(h, 10);
                                if (isNaN(hour) || hour < 0 || hour > 23) {
                                    throw new Error(`Invalid hour in header: ${h}`);
                                }
                                return hour;
                            });
                            
                            for (let i = 1; i < lines.length; i++) {
                                const line = lines[i].trim();
                                if (!line) continue;

                                const cols = this.parseCSVLine(line);
                                if (cols.length !== headers.length) {
                                    throw new Error(`Row ${i + 1} has incorrect number of columns: expected ${headers.length}, got ${cols.length}`);
                                }

                                const date = new Date(cols[0]);
                                if (isNaN(date.getTime())) {
                                    throw new Error(`Invalid date in row ${i + 1}: ${cols[0]}`);
                                }

                                const entries = {};
                                for (let j = 1; j < cols.length; j++) {
                                    const hour = hours[j - 1];
                                    const cellContent = cols[j].trim();
                                    if (cellContent) {
                                        const emojis = Array.from(cellContent.match(/\p{Emoji}/gu) || []);
                                        const text = cellContent.replace(/\p{Emoji}/gu, '').trim();
                                        entries[hour] = { emojis, text };
                                    }
                                }

                                this.allEntries[date.toISOString().split('T')[0]] = entries;
                            }

                            this.saveData();
                            this.render();
                            alert('Data imported successfully');
                        } catch (err) {
                            alert('Error importing data: Invalid CSV format');
                        }
                    }
                };

                if (file.name.endsWith('.json')) {
                    reader.readAsText(file);
                } else if (file.name.endsWith('.csv')) {
                    reader.readAsText(file);
                } else {
                    alert('Invalid file type. Please select a .csv or .json file.');
                }
            }

            parseCSVLine(line) {
                const result = [];
                let current = '';
                let inQuotes = false;
                
                for (let i = 0; i < line.length; i++) {
                    const char = line[i];
                    if (char === '"') {
                        if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                            current += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if (char === ',' && !inQuotes) {
                        result.push(current.trim());
                        current = '';
                    } else {
                        current += char;
                    }
                }
                result.push(current.trim());
                return result;
            }

            wipeCurrentDayData() {
                // Clear entries for the current logical day
                const currentDayKey = this.dateKey(this.currentDate);
                const nextDay = new Date(this.currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                
                // Clear hours 7-23 from current calendar day
                if (this.allEntries[currentDayKey]) {
                    for (let hour = this.startHour; hour < 24; hour++) {
                        delete this.allEntries[currentDayKey][hour];
                    }
                }
                
                // Clear hours 0-6 from next calendar day
                if (this.allEntries[nextDayKey]) {
                    for (let hour = 0; hour < this.startHour; hour++) {
                        delete this.allEntries[nextDayKey][hour];
                    }
                }
                
                this.render();
                this.saveData();
            }

            getDayEmojis() {
                const emojiCounts = {};
                Object.values(this.entries).forEach(entry => {
                    if (entry.emojis) {
                        entry.emojis.forEach(emoji => {
                            emojiCounts[emoji] = (emojiCounts[emoji] || 0) + 1;
                        });
                    }
                });
                return emojiCounts;
            }

            startBubbleAnimation() {
                // Clean up any existing animation
                if (this.bubbleAnimationId) {
                    cancelAnimationFrame(this.bubbleAnimationId);
                    this.bubbleAnimationId = null;
                }

                const container = document.querySelector('.bubbles-container');
                if (!container) return;
                const bubbles = container.querySelectorAll('.bubble');
                const containerRect = container.getBoundingClientRect();
                const bubbleStates = new Map();
                
                // Physics constants
                const centerGravity = 0.015;
                const friction = 0.995;
                const restitution = 0.3;
                const repulsion = 2.0;
                const maxSpeed = 1;
                const minSpeed = 0;
                const gravityDampening = 0.7;

                // Initialize bubbles randomly across the entire container
                // Initialize bubbles with no overlaps
                bubbles.forEach((bubble) => {
                    const size = parseFloat(bubble.style.width);
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;
                    const padding = size;
                    
                    let attempts = 0;
                    let pixelX, pixelY;
                    let overlap;
                    
                    // Try to find non-overlapping position
                    do {
                        pixelX = padding + Math.random() * (containerWidth - size - padding * 2);
                        pixelY = padding + Math.random() * (containerHeight - size - padding * 2);
                        
                        overlap = false;
                        // Check against all existing bubbles
                        bubbleStates.forEach((existingState) => {
                            const dx = (pixelX + size/2) - (existingState.x + existingState.size/2);
                            const dy = (pixelY + size/2) - (existingState.y + existingState.size/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < (size + existingState.size) / 2) {
                                overlap = true;
                            }
                        });
                        attempts++;
                    } while (overlap && attempts < 100); // Prevent infinite loop
                    
                    // Initial velocity with random direction
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 0.5 + 0.5; // 0.5-1.0 base speed
                    const initialVelX = Math.cos(angle) * speed;
                    const initialVelY = Math.sin(angle) * speed;
                
                bubbleStates.set(bubble, {
                    x: pixelX,
                    y: pixelY,
                    vx: initialVelX === 0 ? 0.1 : initialVelX, // Ensure non-zero initial velocity
                    vy: initialVelY === 0 ? 0.1 : initialVelY,
                    size: size,
                });
                });

                let lastFrame = performance.now();
                const animate = (currentTime) => {
                    if (!document.querySelector('.bubbles-container')) {
                        cancelAnimationFrame(this.bubbleAnimationId);
                        this.bubbleAnimationId = null;
                        return; // Stop if container is gone
                    }

                    const deltaTime = Math.min(currentTime - lastFrame, 32); // Cap at ~30fps
                    lastFrame = currentTime;

                    // Apply forces and update positions
                    bubbleStates.forEach((state, bubble) => {
                        // Use mouse position as gravity center when hovering
                        const bubbleCenterX = state.x + state.size / 2;
                        const bubbleCenterY = state.y + state.size / 2;
                        const containerRadius = Math.min(containerRect.width, containerRect.height) / 2;
                        
                        // Default to container center if mouse is not over container
                        const containerCenterX = this.mouseX || containerRect.width / 2;
                        const containerCenterY = this.mouseY || containerRect.height / 2;

                        // Calculate gravity/repulsion with improved stability
                        const dx = containerCenterX - bubbleCenterX;
                        const dy = containerCenterY - bubbleCenterY;
                        const distToCenter = Math.sqrt(dx * dx + dy * dy);
                        if (distToCenter > 0) {
                            // Calculate normalized direction
                            const dirX = dx / distToCenter;
                            const dirY = dy / distToCenter;
                            
                            // Calculate force strength with smooth falloff
                            const normalizedDist = Math.min(distToCenter / containerRadius, 1);
                            let forceStrength;
                            
                            // Repel if mouse is over container, attract otherwise
                            if (this.mouseX != null && this.mouseY != null) {
                                // Stronger repulsion when closer to mouse
                                forceStrength = -centerGravity * 15 * (1 - Math.pow(normalizedDist, 0.8));
                            } else {
                                // Normal center attraction when no mouse
                                forceStrength = centerGravity * 0.7 * Math.pow(normalizedDist, 1.2);
                            }
                            
                            // Apply force with dampening based on current velocity
                            const currentSpeed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                            const dampening = Math.max(0, 1 - (currentSpeed / maxSpeed) * gravityDampening);
                            
                            state.vx += dirX * forceStrength * dampening;
                            state.vy += dirY * forceStrength * dampening;
                        }

                        // Apply friction
                        state.vx *= friction;
                        state.vy *= friction;

                        // Maintain minimum and maximum speed
                        const speed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                        if (speed < minSpeed) {
                            const scale = minSpeed / speed;
                            state.vx *= scale;
                            state.vy *= scale;
                        } else if (speed > maxSpeed) {
                            const scale = maxSpeed / speed;
                            state.vx *= scale;
                            state.vy *= scale;
                        }

                        // Update position
                        state.x += state.vx;
                        state.y += state.vy;

                        // Bounce off container bounds (rectangular boundary)
                        const radius = state.size / 2;
                        
                        // Right wall
                        if (state.x + state.size > containerRect.width) {
                            state.x = containerRect.width - state.size;
                            state.vx *= -restitution;
                        }
                        // Left wall
                        if (state.x < 0) {
                            state.x = 0;
                            state.vx *= -restitution;
                        }
                        // Bottom wall
                        if (state.y + state.size > containerRect.height) {
                            state.y = containerRect.height - state.size;
                            state.vy *= -restitution;
                        }
                        // Top wall
                        if (state.y < 0) {
                            state.y = 0;
                            state.vy *= -restitution;
                        }

                        const newX = (state.x / containerRect.width) * 100;
                        const newY = (state.y / containerRect.height) * 100;
                        
                        if (Math.abs(parseFloat(bubble.style.left) - newX) > 0.01 ||
                            Math.abs(parseFloat(bubble.style.top) - newY) > 0.01) {
                            bubble.style.left = `${newX}%`;
                            bubble.style.top = `${newY}%`;
                        }
                    });

                    // Handle collisions between bubbles
                    const bubbleArray = Array.from(bubbleStates.entries());
                    for (let i = 0; i < bubbleArray.length; i++) {
                        const [bubble1, state1] = bubbleArray[i];
                        for (let j = i + 1; j < bubbleArray.length; j++) {
                            const [bubble2, state2] = bubbleArray[j];
                            
                            // Calculate centers
                            const center1X = state1.x + state1.size / 2;
                            const center1Y = state1.y + state1.size / 2;
                            const center2X = state2.x + state2.size / 2;
                            const center2Y = state2.y + state2.size / 2;
                            
                            // Check collision
                            const dx = center2X - center1X;
                            const dy = center2Y - center1Y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDist = (state1.size + state2.size) / 2;

                            if (distance < minDist) {
                                // Normalize collision vector
                                const nx = dx / distance;
                                const ny = dy / distance;
                                
                                const relativeVelX = state2.vx - state1.vx;
                                const relativeVelY = state2.vy - state1.vy;
                                
                                const relativeSpeed = relativeVelX * nx + relativeVelY * ny;
                                
                                if (relativeSpeed > 0) continue;
                                
                                const overlap = minDist - distance;
                                state1.x -= nx * overlap * 0.5;
                                state1.y -= ny * overlap * 0.5;
                                state2.x += nx * overlap * 0.5;
                                state2.y += ny * overlap * 0.5;
                                
                                const repulsionForce = repulsion * Math.min(1.0, overlap / minDist);
                                state1.vx -= nx * repulsionForce;
                                state1.vy -= ny * repulsionForce;
                                state2.vx += nx * repulsionForce;
                                state2.vy += ny * repulsionForce;
                            }
                        }
                    }

                    this.bubbleAnimationId = requestAnimationFrame(animate);
                };
                
                this.bubbleAnimationId = requestAnimationFrame(animate);

                // Track mouse position using event delegation
                container.addEventListener('mouseenter', (e) => {
                    const bubble = e.target.closest('.bubble');
                    if (bubble) {
                        const rect = container.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                    }
                });

                container.addEventListener('mousemove', (e) => {
                    const bubble = e.target.closest('.bubble');
                    if (bubble) {
                        const rect = container.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                    }
                });

                container.addEventListener('mouseout', (e) => {
                    const bubble = e.target.closest('.bubble');
                    const relatedBubble = e.relatedTarget?.closest('.bubble');
                    if (bubble && !relatedBubble) {
                        this.mouseX = null;
                        this.mouseY = null;
                    }
                });

                // Handle window resize
                this.resizeObserver?.disconnect();
                this.resizeObserver = new ResizeObserver(() => {
                    // Recalculate container dimensions
                    const newRect = container.getBoundingClientRect();
                    const scaleX = newRect.width / containerRect.width;
                    const scaleY = newRect.height / containerRect.height;
                    
                    // Scale bubble positions to new container size
                    bubbleStates.forEach((state, bubble) => {
                        state.x *= scaleX;
                        state.y *= scaleY;
                    });
                    
                    // Update container rect reference
                    Object.assign(containerRect, newRect);
                });
            }

            // === RENDER ===
            render() {
                this.updateUndoButton();
                this.checkGoals(); // Always update/check dailies on UI update

                if (this.view === 'timeline') {
                    this.renderTimeline();
                } else if (this.view === 'settings') {
                    this.renderSettings();
                } else if (this.view === 'daily') {
                    this.renderDaily();
                }
            }

            renderTimeline() {
                document.getElementById('mainContainer').innerHTML = `
                    <div class="scroll-container">
                        <div class="date-nav">
                            <div class="date-nav-left">
                                <div class="date-btn" onclick="app.navigateDay(-1)" title="Previous day (Left Arrow)">←</div>
                                <input type="text" 
                                    class="date-input secondary-btn"
                                    value="${this.formatDateInput()}"
                                    maxlength="8"
                                    onkeydown="app.handleDateKeydown(event)"
                                    oninput="app.handleDateInput(event)"
                                    onfocus="app.handleDateFocus(event)"
                                    title="Focus date input (Press 'F')">
                                <div class="date-btn" onclick="app.navigateDay(1)" title="Next day (Right Arrow)">→</div>
                            </div>
                            <div class="date-nav-right">
                                <div onclick="app.jumpToToday()" title="Return to current day">jump to now</div>
                            </div>
                        </div>
                        <div id="goalsSection"></div>
                        <div id="hoursContainer"></div>
                    </div>
                    <div class="scroll-bar ${this.editingHour !== null ? 'hidden' : ''}" id="customScrollBar"></div>
                `;

                const container = document.querySelector('.main-container');
                container.addEventListener('scroll', this.handleScroll.bind(this));
                if (this.timelineScrollPosition > 0) {
                    container.scrollTop = this.timelineScrollPosition;
                }

                // Custom scrollbar logic
                const scrollBar = document.getElementById('customScrollBar');
                let isDragging = false;
                let startY = 0;
                let startScroll = 0;

                scrollBar.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startScroll = container.scrollTop;
                    scrollBar.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaY = e.clientY - startY;
                    container.scrollTop = startScroll - deltaY * 2; // inverted direction, 2x impact
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        scrollBar.classList.remove('dragging');
                        document.body.style.userSelect = '';
                    }
                });

                // Double click to jump to now
                scrollBar.addEventListener('dblclick', () => {
                    app.jumpToToday();
                });

                this.renderGoals();
                this.renderHours();
            }

            renderGoals() {
                const goalsSection = document.getElementById('goalsSection');
                if (!goalsSection) return;
                
                const goalChecks = this.checkGoals();

                if (this.goals.length > 0 && this.showGoalsInTimeline) {
                    goalsSection.innerHTML = `
                        <div class="goals-section">
                            ${goalChecks.map(goal => `
                                <div class="goal-item ${goal.met ? 'passed' : 'failed'}">
                                    <span class="goal-text">${this.formatGoalText(goal)}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else if (this.goals.length === 0 && this.showGoalsInTimeline) {
                    goalsSection.innerHTML = '<div class="no-goals">no dailies set - add in settings</div>';
                } else {
                    goalsSection.innerHTML = '';
                }
            }

            renderHours() {
                this.saveData();
                const hoursContainer = document.getElementById('hoursContainer');
                if (!hoursContainer) return;
                
                hoursContainer.innerHTML = `
                    <div class="hours-container">
                        ${this.hours.map(hour => {
                            const entry = this.entries[hour] || { emojis: [], text: '' };
                            const isCurrent = this.isCurrentHour(hour);
                            const isEditing = this.editingHour === hour;
                            const hourFill = this.getHourFill(hour);
                            // Show all emojis if there's no text, otherwise limit to 6
                            const emojis = (entry.emojis || []).slice(0, entry.text ? 6 : undefined);

                            return `
                                <div class="hour-row">
                                    ${isEditing ? `
                                        <div class="emoji-picker below">
                                            ${this.emojis.map(emoji => `
                                                <button class="emoji-btn ${entry.emojis?.includes(emoji) ? 'selected' : ''}"
                                                        onclick="app.toggleEmoji('${emoji}')">
                                                    ${emoji}
                                                </button>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="hour-entry ${isCurrent ? 'current' : ''} ${isEditing ? 'editing' : ''}"
                                         data-hour="${hour}"
                                         onclick="app.editHour(${hour})">
                                        ${hourFill > 0 ? `<div class="hour-fill ${!entry.text && !entry.emojis?.length ? 'empty' : ''}" style="width: ${hourFill}%;"></div>` : ''}
                                        <div class="hour-content">
                                            <span class="hour-time">${this.formatHour(hour)}</span>
                                            <div class="hour-emojis">
                                                ${emojis.map(emoji => `<span class="emoji">${emoji}</span>`).join('')}
                                            </div>
                                            ${isEditing ? `
                                                <div class="hour-input-container">
                                                    <textarea class="hour-input"
                                                           placeholder="${this.isFutureDate() ? 'Plan ahead...' : this.isPastDate() ? 'Remember...' : 'What happened?'}"
                                                           oninput="app.updateText(this.value)"
                                                           onkeydown="app.handleHourInputKeydown(event, ${hour})"
                                                           onclick="event.stopPropagation()">${entry.text}</textarea>
                                                    <button class="clear-btn" onclick="event.stopPropagation(); app.clearEntry(${hour})">×</button>
                                                </div>
                                            ` : `<span class="hour-text">${entry.text.replace(/\n/g, '<br>')}</span>`}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        ${this.editingHour !== null ? '<div class="overlay" onclick="app.editingHour = null; app.renderHours()"></div>' : ''}
                    </div>
                `;
                this.attachCopyPasteEvents();
            }

            renderSettings() {
                document.getElementById('mainContainer').innerHTML = `
                    <div class="settings-container">
                        <div class="setting-group">
                            <label class="setting-label">Available Emojis</label>
                            <input type="text" class="setting-input emoji-input" value="${this.emojis.join('')}"
                                   oninput="app.handleEmojiInput(this.value)">
                        </div>
                        
                        <div class="setting-group">
                            <label class="setting-label">Dailies</label>
                            <div id="goalsList"></div>
                            <div style="display: flex; align-items: center; justify-content: space-between; gap: 16px; margin-top: 12px;">
                                <button class="add-goal-btn" onclick="app.addGoal()">+ Add Daily</button>
                                <label class="checkbox-label" style="margin-bottom: 0;">
                                    <input type="checkbox" class="checkbox" ${this.showGoalsInTimeline ? 'checked' : ''} onchange="app.showGoalsInTimeline = this.checked; app.saveData()">
                                    <span>Show dailies in timeline</span>
                                </label>
                            </div>
                        </div>

                        <div class="setting-group">
                            <label class="setting-label">Start Hour</label>
                            <select class="setting-input" onchange="app.startHour = parseInt(this.value); app.saveData()">
                                ${Array.from({length: 24}, (_, i) => `
                                    <option value="${i}" ${i === this.startHour ? 'selected' : ''}>
                                        ${this.formatHour(i)}:00
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div class="setting-group">
                            <div class="export-section">
                                <button class="export-toggle" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.querySelector('.export-arrow').classList.toggle('open')">
                                    Export/Import Data
                                    <span class="export-arrow">▼</span>
                                </button>
                                <div class="export-content" style="display: none;">
                                    <button class="export-btn" onclick="app.exportAllToCSV()" style="margin-bottom: 12px;">
                                        Export All Data
                                    </button>
                                    <div class="import-section">
                                        <input type="file" class="import-input" accept=".csv,.json" 
                                               onchange="if(this.files.length) app.importFromCSVFile(this.files[0])">
                                    </div>
                                    <div class="export-help">
                                        Export creates two files:
                                        <br>• Monthly CSV files with daily entries
                                        <br>• JSON file with settings and goals
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        ${this.editingGoal !== null ? '<div class="overlay" onclick="app.editingGoal = null; app.renderSettings()"></div>' : ''}
                    </div>
                `;

                this.renderGoalsList();
            }

            renderGoalsList() {
                const goalsList = document.getElementById('goalsList');
                if (!goalsList) return;
                goalsList.innerHTML = this.goals.map(goal => {
                    const isEditing = this.editingGoal === goal.id;
                    const selectedEmojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                    return `
                        <div class="goal-row">
                            <div class="goal-summary ${isEditing ? 'editing' : ''}" onclick="app.editGoal(${goal.id})">
                               <span class="goal-text-display">${this.formatGoalText(goal)}</span>
                                <button class="remove-goal-btn" onclick="event.stopPropagation(); app.removeGoal(${goal.id})">×</button>
                            </div>
                            ${isEditing ? `
                                <div class="goal-editor">
                                    <div class="goal-editor-section">
                                        <label class="goal-editor-label">Choose Emojis</label>
                                        <div class="goal-emoji-grid">
                                            ${this.emojis.map(emoji => `
                                                <button class="goal-emoji-btn ${selectedEmojis.includes(emoji) ? 'selected' : ''}"
                                                        onclick="app.toggleGoalEmoji(${goal.id}, '${emoji}')">
                                                    ${emoji}
                                                </button>
                                            `).join('')}
                                        </div>
                                    </div>
                                    <div class="goal-editor-section">
                                        <label class="goal-editor-label">Set Condition</label>
                                        <div class="operator-value-group">
                                            <button class="goal-action-btn" onclick="app.toggleGoalNegation(${goal.id})">
                                                ${goal.not ? 'is not' : 'is'}
                                            </button>
                                            <button class="goal-operator-btn" onclick="app.cycleOperator(${goal.id})">
                                                ${goal.operator.replace('_', ' ')}
                                            </button>
                                            <input type="number" 
                                                   class="goal-value-input" 
                                                   value="${goal.value}" 
                                                   min="0" 
                                                   max="23"
                                                   onclick="event.stopPropagation()"
                                                   onblur="app.updateGoal(${goal.id}, { value: parseInt(this.value) || 0 })">
                                            <span style="color: #e5e7eb; font-size: 16px;">
                                                ${goal.operator.includes('than') ? 'times' : ''}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            }
            handleEmojiInput(value) {
                // First, keep only emoji characters
                const emojiRegex = /\p{Emoji}/gu;
                const emojis = Array.from(new Set(value.match(emojiRegex) || []));
                
                // Only update if we have at least one emoji
                if (emojis.length > 0) {
                    this.emojis = emojis;
                    this.saveData();
                }
            }

            toggleGoalEmoji(goalId, emoji) {
                const goal = this.goals.find(g => g.id === goalId);
                let emojis = Array.isArray(goal.emojis) ? [...goal.emojis] : [goal.emoji];
                if (emojis.includes(emoji)) {
                    emojis = emojis.filter(e => e !== emoji);
                } else {
                    emojis.push(emoji);
                }
                if (emojis.length === 0) emojis = [emoji];
                this.updateGoal(goalId, { emojis });
            }
            toggleGoalNegation(goalId) {
                const goal = this.goals.find(g => g.id === goalId);
                this.updateGoal(goalId, { not: !goal.not });
            }
            

            renderDaily() {
                const dayEmojis = this.getDayEmojis();
                const goalChecks = this.checkGoals();
                
                document.getElementById('mainContainer').innerHTML = `
                    <div class="daily-container">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 16px;">
                            <button class="jump-btn" onclick="if(confirm('Clear all data for this day?')) { app.wipeCurrentDayData(); }">🗑️ wipe</button>
                            <button class="jump-btn" onclick="app.exportCurrentDayCSV()">📋 copy</button>
                        </div>
                        
                        <div class="bubbles-container">
                            ${(() => {
                                let bubbles = [];
                                Object.entries(this.entries).forEach(([hour, entry]) => {
                                    if (entry.emojis && entry.emojis.length > 0) {
                                        const uniqueEmojis = new Set(entry.emojis);
                                        entry.emojis.forEach((emoji, index) => {
                                            let size;
                                            if (uniqueEmojis.size === 1) {
                                                size = 70; // Large for single emoji
                                            } else if (uniqueEmojis.size === 2) {
                                                size = 50; // Medium for two emojis
                                            } else {
                                                size = 40; // Small for three or more
                                            }

                                            // Generate a unique ID for the bubble
                                            const bubbleId = `bubble-${hour}-${index}`;
                                            
                                            // Use stored position if available, otherwise random
                                            let x = 5, y = 5;
                                            if (this.restoreBubbleStates) {
                                                const stored = this.restoreBubbleStates.find(b => b.id === bubbleId);
                                                if (stored) {
                                                    x = (stored.state.x / containerWidth) * 100;
                                                    y = (stored.state.y / containerHeight) * 100;
                                                } else {
                                                    x = Math.random() * 90 + 5; // 5-95%
                                                    y = Math.random() * 90 + 5; // 5-95%
                                                }
                                            } else {
                                                x = Math.random() * 90 + 5; // 5-95%
                                                y = Math.random() * 90 + 5; // 5-95%
                                            }
                                            
                                            bubbles.push(`
                                                <div class="bubble" style="
                                                    left: ${x}%; 
                                                    top: ${y}%; 
                                                    width: ${size}px; 
                                                    height: ${size}px; 
                                                    font-size: ${size * 0.5}px;
                                                    transition: none;
                                                    border-radius: 50%;
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    background-color: rgba(31, 41, 55, 0.7);
                                                ">
                                                    ${emoji}
                                                </div>
                                            `);
                                        });
                                    }
                                });
                                return bubbles.join('');
                            })()}
                        </div>
                        
                        <div class="dailies-section">
                            <h3>Dailies</h3>
                            ${goalChecks.map(goal => `
                                <div class="goal-item ${goal.met ? 'passed' : 'failed'}" style="margin-bottom:8px;">
                                    <span class="goal-text">${this.formatGoalText(goal)}</span>
                                </div>
                            `).join('')}
                            ${this.goals.length === 0 ? '<p class="no-goals-daily">No dailies set</p>' : ''}
                        </div>
                    </div>
                `;
                
                this.startBubbleAnimation();
            }
        }

        const app = new HourliesApp();
    </script>
</body>
</html>
