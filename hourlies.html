<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hourlies</title>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        :root {
            --header-height: calc(48px + env(safe-area-inset-top, 16px));
            
            /* Base Colors - 6 shades */
            --color-bg-darkest: #111827;  /* Primary background */
            --color-bg-dark: #1f2937;     /* Secondary/header background */
            --color-bg-medium: #2a313e;   /* Tertiary/input background */
            --color-bg-light: #343d4e;    /* Quaternary/card background */
            --color-bg-lighter: #373e49;  /* Hover states */
            --color-bg-accent: #334970;   /* Primary buttons */
            
            /* Text Colors - 3 shades */
            --color-text-primary: #ffffff;
            --color-text-secondary: #d1d5db;
            --color-text-muted: #b4bdd0;
            
            /* Accent Colors - 3 colors */
            --color-accent-blue: #3b82f6;   /* Focus/current states */
            --color-accent-green: #364e36;  /* Success states */
            --color-accent-red: #d83939;    /* Error states */
            --color-accent-red-muted: #852727;    /* Failed dailies */
        }

        html {
            height: -webkit-fill-available;
        }

        body {
            font-family: 'Atkinson Hyperlegible', sans-serif;
            background-color: var(--color-bg-darkest);
            color: var(--color-text-primary);
            margin: 0;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* LAYOUT */
        #app {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        .header {
            background-color: var(--color-bg-dark);
            padding: env(safe-area-inset-top, 16px) 12% 12px 12%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            min-height: var(--header-height);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
        }
        
        .main-container {
            flex: 1;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            position: relative;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer and Edge */
            padding: 0;
            margin: 0;
        }
        
        .main-container::-webkit-scrollbar {
            display: none;  /* Chrome, Safari, and Opera */
        }
        
        .settings-container, .daily-container {
            padding: 16px 12%;
            min-height: 100%;
        }
        
        .scroll-container {
            padding: 16px 12%;
            margin: 0;
            min-height: 100%;
            position: relative;
            /* Hide default scrollbar */
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer and Edge */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }
        
        .scroll-container::-webkit-scrollbar {
            display: none;  /* Chrome, Safari, and Opera */
        }
        
        /* BUTTONS & INPUTS */
        .btn {
            background: none;
            border: none;
            color: var(--color-text-muted);
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
        }
        
        .btn:hover, .btn-active {
            color: var(--color-text-primary);
        }
        
        .btn-active {
            font-weight: 700;
        }
        
        input, select, textarea {
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-family: inherit;
            transition: color 0.2s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            color: var(--color-text-primary);
        }
        
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        input[type=number] {
            -webkit-appearance: textfield;
            appearance: textfield;
        }
        
        textarea {
            color: var(--color-text-secondary);
            font-size: 20px;
        }       
        /* HEADER */
        .header h1 {
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 700;
            cursor: pointer;
            transition: color 0.2s;
            color: var(--color-text-muted);
            padding-top: 16px;
        }
        
        .header h1:hover {
            color: var(--color-text-primary);
        }
        
        .header-buttons {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        
        .btn-label {
            font-size: clamp(1.1rem, 2.5vw, 1.3rem);
            vertical-align: middle;
        }
        
        /* DATE NAVIGATION */
        .date-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-top: 1rem;
        }
        
        .date-nav-left, .date-nav-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--color-text-muted);
        }
        
        .date-input {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            text-align: center;
            width: clamp(120px, 30vw, 140px);
            cursor: pointer;
        }
        .date-btn {
            background-color: transparent;
            color: var(--color-text-muted);
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        .secondary-btn {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        
        .jump-btn {
            background-color: var(--color-bg-dark);
            color: var(--color-text-muted);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        
        .jump-btn:hover {
            color: var(--color-text-secondary);
        }
        
        /* GOALS */
        .goals-section {
            margin-bottom: 16px;
            padding: 0px;
            background-color: transparent;
            border-radius: 8px;
        }
        
        .goals-title {
            font-weight: 600;
            color: var(--color-text-secondary);
            margin-bottom: 8px;
        }
        
        .goal-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            width: fit-content;
        }
        
        .goal-item.passed {
            background-color: var(--color-accent-green);
        }
        
        .goal-item.failed {
            background-color: var(--color-accent-red-muted);
        }
        
        .goal-text {
            color: var(--color-text-secondary);
            font-size: 1.6em;
            font-weight: 500;
        }
        
        .no-goals {
            padding: 8px 12px;
            border-radius: 4px;
            background-color: var(--color-bg-medium);
            color: var(--color-text-muted);
            text-align: center;
            font-size: 14px;
        }
        
        /* HOURS */
        .hour-row {
            position: relative;
            margin-bottom: 8px;
        }
        
        .hour-entry {
            position: relative;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 4px;
            background-color: var(--color-bg-light);
            overflow: hidden;
            transition: all 0.2s;
        }
        
        .hour-entry:hover {
            background-color: var(--color-bg-lighter);
        }
        
        .hour-entry.current {
            box-shadow: 0 0 0 2px var(--color-accent-blue);
        }
        
        .hour-entry.editing {
            position: relative;
            box-shadow: 0 0 0 2px var(--color-accent-blue);
            z-index: 1000;
            user-select: text;
        }
        
        .hour-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: var(--color-bg-accent);
        }
        
        .hour-fill.empty {
            background-color: var(--color-bg-dark);
        }
        
        .hour-content {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }
        
        .hour-time {
            font-size: 24px;
            width: 32px;
        }
        
        .hour-emojis {
            display: grid;
            grid-template-columns: repeat(2, 30px);
            gap: 4px;
            min-height: 30px;
            max-height: calc(30px * 3 + 8px);
            overflow: hidden;
            max-width: 64px;
            min-width: 64px;
            padding-right: 24px;
        }
        
        .hour-entry:not(.editing) .hour-content:has(.hour-text:empty) .hour-emojis {
            display: flex;
            flex-wrap: nowrap;
            gap: 4px;
            max-width: none;
            min-width: 0;
            overflow-x: auto;
        }
        
        .emoji {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            min-height: 28px;
        }
        
        .hour-input-container {
            flex: 1;
            display: flex;
            align-items: flex-start;
            position: relative;
        }
        
        .hour-input {
            flex: 1;
            background: transparent;
            color: var(--color-text-secondary);
            resize: none;
            overflow: hidden;
            min-height: 36px;
            line-height: 1.5;
            margin-top: 4px;
            transition: height 0.15s ease-out;
            user-select: text;
            white-space: pre-wrap;
        }
        
        .hour-input::placeholder {
            color: var(--color-text-muted);
        }
        
        .hour-input.empty {
            color: var(--color-text-muted);
        }
        
        .hour-input.scrolling {
            overflow-y: auto;
        }
        
        .hour-text {
            color: var(--color-text-secondary);
            font-size: 20px;
            white-space: pre-wrap;
        }
        
        .clear-btn {
            position: absolute;
            right: 0;
            top: 0;
            background: none;
            border: none;
            color: var(--color-accent-red);
            cursor: pointer;
            font-size: 36px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        /* EMOJI PICKER */
        .emoji-picker {
            position: absolute;
            left: 0;
            right: 0;
            background-color: var(--color-bg-dark);
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, 64px);
            justify-content: center;
            gap: 8px;
            z-index: 1001;
            border-radius: 4px;
            box-shadow: 0 10px 25px var(rgba(0, 0, 0, 0.5));
        }
        
        .emoji-picker.above {
            bottom: 100%;
            margin-bottom: 8px;
        }
        
        .emoji-picker.below {
            top: 100%;
            margin-top: 8px;
        }
        
        .emoji-btn {
            padding: 8px;
            font-size: 48px;
            background: none;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 4px;
        }
        
        .emoji-btn:hover {
            background-color: var(--color-bg-lighter);
        }
        
        .emoji-btn.selected {
            background-color: var(--color-bg-accent);
        }
        
        .emoji-btn.selected:hover {
            background-color: var(--color-accent-blue);
        }
        
        /* SCROLL BAR */
        .scroll-bar {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 48px;
            cursor: ns-resize;
            transition: all 0.2s;
            background: repeating-linear-gradient(
                45deg,
                transparent 0px,
                transparent 3px,
                rgba(255,255,255,0.08) 3px,
                rgba(255,255,255,0.08) 4px,
                transparent 4px,
                transparent 8px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent 0px,
                transparent 3px,
                rgba(255,255,255,0.08) 3px,
                rgba(255,255,255,0.08) 4px,
                transparent 4px,
                transparent 8px
            );
        }
        
        .scroll-bar.hidden {
            display: none;
        }
        
        .scroll-bar.dragging {
            background-color: var(rgba(255, 255, 255, 0.1));
        }
        
        .hour-indicator {
            position: absolute;
            right: 8px;
            width: 0;
            height: 0;
            border-left: 6px solid var(--color-accent-blue);
            border-top: 3px solid transparent;
            border-bottom: 3px solid transparent;
            animation: pulse 2s infinite;
            pointer-events: none;
            transform: translateY(-50%);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* SETTINGS */
        .setting-group {
            margin-bottom: 24px;
        }
        
        .setting-label {
            display: block;
            color: var(--color-text-secondary);
            margin-bottom: 8px;
            font-size: 1.5rem;
        }
        
        .setting-input {
            width: 100%;
            padding: 12px;
            background-color: var(--color-bg-medium);
            color: var(--color-text-primary);
            border-radius: 4px;
            font-size: 18px;
            font-family: 'Atkinson Hyperlegible', monospace;
        }
        .emoji-input {
            font-size: 1.2em;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: normal;
            line-height: 1.5;
            min-height: 6em;
            resize: none;
            transition: all 0.3s ease;
        }
        
        .emoji-input:focus {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            max-width: 600px;
            height: 80vh;
            z-index: 1050;
            padding: 20px;
            box-shadow: 0 0 20px var(rgba(0, 0, 0, 0.5));
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            padding: 12px 16px;
            background-color: var(--color-bg-lighter);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
            user-select: none;
            min-height: 48px;
        }
        
        .checkbox-label:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-text-muted);
        }
        
        .checkbox {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }
        
        .add-goal-btn, .export-btn {
            background-color: var(--color-bg-accent);
            color: var(--color-text-primary);
            border: 2px solid transparent;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 18px;
            font-weight: 500;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-goal-btn:hover, .export-btn:hover {
            background-color: var(--color-accent-blue);
            border-color: var(--color-accent-blue);
            transform: translateY(-1px);
        }
        
        /* GOAL EDITOR */
        .goal-row {
            position: relative;
            margin-bottom: 12px;
            display: flex;
            justify-content: center;
        }
        
        .goal-summary {
            cursor: pointer;
            padding: 12px;
            background-color: var(--color-bg-medium);
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            width:100%
        }
        
        .goal-summary:hover {
            background-color: var(--color-bg-lighter);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px var(rgba(0, 0, 0, 0.2));
        }
        
        .goal-summary.editing {
            background-color: var(--color-bg-dark);
            box-shadow: 0 4px 12px var(rgba(0, 0, 0, 0.3));
            transform: scale(1.02);
        }
                
        .goal-text-display {
            color: var(--color-text-secondary);
            flex: 1;
            font-size: 1.2rem;
        }
        
        .remove-goal-btn {
            background: none;
            border: none;
            color: var(--color-text-muted);
            cursor: pointer;
            font-size: 20px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .remove-goal-btn:hover {
            background-color: var(--color-bg-lighter);
            color: var(--color-accent-red);
        }
        
        .goal-editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(90%, 800px);
            max-width: 800px;
            padding: 24px;
            background-color: var(--color-bg-dark);
            border-radius: 8px;
            border: 2px solid var(--color-bg-lighter);
            z-index: 1100;
            box-shadow: 0 4px 12px var(rgba(0, 0, 0, 0.3));
        }
        
        .goal-editor-section {
            width: 100%;
        }

        .goal-emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 8px;
            margin-bottom: 16px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            padding: 4px;
            border-radius: 8px;
        }

        .operator-value-group {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            background: var(--color-bg-darkest);
            padding: 16px;
            border-radius: 8px;
        }
        
        .goal-emoji-btn {
            background: var(--color-bg-darkest);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 8px;
            transition: all 0.2s;
        }
        
        .goal-emoji-btn:hover {
            background-color: var(--color-bg-lighter);
            transform: scale(1.05);
        }
        
        .goal-emoji-btn.selected {
            border-color: var(--color-accent-blue);
            background-color: var(--color-bg-dark);
        }
        
        .goal-toggle {
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
            padding: 12px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s;
            min-height: 44px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .goal-toggle:hover {
            background-color: var(--color-bg-lighter);
            transform: translateY(-1px);
        }
        
        .goal-action-btn,
        .goal-operator-btn {
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
            padding: 12px 18px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s;
            min-height: 44px;
            min-width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            min-width: 25%;
        }
        
        .goal-action-btn:hover,
        .goal-operator-btn:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
            transform: translateY(-1px);
        }
        
        .goal-value-input {
            width: 80px;
            padding: 8px 12px;
            background-color: var(--color-bg-medium);
            border-radius: 6px;
            color: var(--color-text-secondary);
            font-size: 1.2em;
            text-align: center;
            min-width: 25%;
        }
        
        .goal-operator-btn:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
        }
        
        .goal-value-input {
            width: 70px;
            text-align: center;
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
            border: 2px solid transparent;
            border-radius: 6px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            transition: all 0.2s;
        }
        
        .goal-value-input:hover,
        .goal-value-input:focus {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
            outline: none;
        }
        
        .goal-editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
        }
        
        .goal-action-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
        }
        
        .goal-action-btn:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
        }
        
        .goal-action-btn.secondary:hover {
            background-color: var(--color-bg-lighter);
        }
        
        /* EXPORT/IMPORT */
        .export-section {
            background-color: var(--color-bg-medium);
            border-radius: 4px;
            overflow: hidden;
        }

        .export-toggle {
            width: 100%;
            background-color: var(--color-bg-medium);
            color: var(--color-text-primary);
            border: none;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .export-toggle:hover {
            background-color: var(--color-bg-lighter);
        }
        
        .export-arrow {
            transition: transform 0.2s;
        }
        
        .export-arrow.open {
            transform: rotate(180deg);
        }
        
        .export-content {
            padding: 12px;
            background-color: var(--color-bg-medium);
        }
        
        .import-section {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .import-input {
            flex: 1;
            padding: 8px;
            background-color: var(--color-bg-lighter);
            color: var(--color-text-primary);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .export-help {
            font-size: 12px;
            color: var(--color-text-muted);
            padding-top: 8px;
            border-top: 1px solid var(--color-bg-lighter);
        }
        
        /* DAILY VIEW */
        .bubbles-container {
            border-radius: 8px;
            height: 350px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--color-bg-medium);
            margin-bottom: 24px;
        }
        
        .bubble {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: var(--color-text-primary);
            background-color: var(--color-bg-dark);
        }
        
        .dailies-section h3 {
            font-size: 1.5rem;
            color: var(--color-text-secondary);
            margin-bottom: 12px;
        }
        
        .no-goals-daily {
            color: var(--color-text-muted);
            font-size: 14px;
        }
        
        /* ANIMATIONS */
        @keyframes flash-border {
            0% { box-shadow: 0 0 0 2px white; }
            100% { box-shadow: none; }
        }
        
        .hour-entry.flash {
            animation: flash-border 0.5s ease;
        }
        
        /* MOBILE */
        @media (max-width: 768px) {
            .scroll-bar { display: none !important; }
            .header { 
                padding: calc(env(safe-area-inset-top, 16px)) 16px 8px 16px;
                min-height: var(--header-height);
            }
            .settings-container, .daily-container { 
                padding: 16px;
                margin-top: 0;
            }
            .main-container {
                padding-bottom: 6rem;
            }
            
            .scroll-container { 
                padding: 16px 0; 
                margin: 0 16px;
            }
            .header h1 { font-size: 1.4em; }
            .btn { font-size: 1.3em !important; }
            .btn-label { font-size: 0.6em; }
            .date-nav { margin-bottom: 12px; }
            .secondary-btn, .date-input { font-size: 22px; }
            .date-input { width: 140px; }
            .hour-time { font-size: 20px; width: 28px; }
            .hour-emojis { grid-template-columns: repeat(2, 26px); gap: 2px; max-width: 54px; min-width: 54px; }
            .emoji { font-size: 24px; min-height: 24px; }
            .hour-text, .hour-input { font-size: 16px; }
            .emoji-picker { grid-template-columns: repeat(auto-fit, 42px); gap: 4px; padding: 8px; }
            .emoji-btn { width: 48px; height: 48px; font-size: 28px; }
            .setting-label, .setting-input, .checkbox-label { font-size: 16px; }
            .setting-input { padding: 10px; }
            .checkbox { width: 18px; height: 18px; }
            .dailies-section h3 { font-size: 16px; }
            .goal-text-display { font-size: 16px; }
        }
        
        @media (max-width: 375px) {
            .header { 
                padding: env(safe-area-inset-top, 12px) 12px 6px 12px;
                min-height: calc(48px + env(safe-area-inset-top, 12px));
            }
            .header h1 { font-size: 1.2em; }
            .btn { font-size: 1.2em !important; }
            .btn-label { font-size: 0.55em; }
            .settings-container, .daily-container { padding: 8px 12px; }
            .scroll-container { padding: 8px 0; margin: 0 12px; }
            .hour-time { font-size: 18px; width: 24px; }
            .hour-emojis { grid-template-columns: repeat(2, 24px); max-width: 50px; min-width: 50px; }
            .emoji { font-size: 22px; min-height: 22px; }
            .hour-text, .hour-input { font-size: 16px; }
            .emoji-picker { grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 6px; }
            .emoji-btn { padding: 4px; font-size: 24px; }
            .date-input, .secondary-btn { font-size: 18px; }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <div style="display: flex; align-items: center; gap: 16px;">
                <h1><div class="btn-active" id="floatingNavDate">hourlies</div></h1>
                <button class="btn" onclick="app.undo()" id="undoBtn" style="display: none;">âŽŒ</button>
            </div>
            <div class="header-buttons">
                <button class="btn" onclick="app.setView('daily')" title="Press 'D'">ðŸŽ¯ <span class="btn-label">daily</span></button>
                <button class="btn" onclick="app.setView('settings')" title="Press 'E'">âš™ <span class="btn-label">edit</span></button>
            </div>
        </div>
        <div class="main-container" id="mainContainer"></div>
    </div>

    <script>
        class HourliesApp {

            constructor() {
                this.currentTime = new Date();
                this.startHour = 7;
                this.allEntries = {};
                this.goals = [];
                this.emojis = [
                    // Core categories
                    'ðŸ”µ', 'ðŸŸ¡', 'ðŸŸ¢', 'ðŸŸ£',
                    // Everyday basics  
                    'ðŸ”', 'â˜•', 'ï¿½', 'ðŸ‘£',
                    // Social & emotional
                    'ðŸ’¬', 'â™¥ï¸', 'ðŸ¥µ',
                    // Extras
                    'ï¿½', 'ðŸŽ®', 'ðŸ‘©â€ðŸ’»', 'ðŸŽ¨',
                    // Additional commonly used
                    'ðŸŒ¿', 'ðŸ”´', 'ðŸŸ©', 'ðŸ“·', 'ðŸ’Š', 'ðŸ•'
                ];
                this.emojiDescriptions = ''; // Store the full emoji input text
                this.showGoalsInTimeline = false;
                
                this.currentDate = new Date();
                this.editingHour = null;
                this.editingGoal = null;
                this.view = 'timeline';
                this.undoStack = [];
                this.clipboardEntry = null;
                this.timelineScrollPosition = 0;
                this.hoveredHour = null; // Track which hour entry is currently being hovered
                this.editStartState = null; // Store entries state when editing starts

                this.loadData();
                this.currentDate = this.getEffectiveDate();
                this.render();
                this.startTimer();
                this.setupEvents();
                setTimeout(() => this.scrollToCurrentHour(), 100);
            }

            // === DATA ===
            loadData() {
                const saved = localStorage.getItem("hourliesData");
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        Object.assign(this, {
                            allEntries: data.allEntries || {},
                            goals: data.goals || [],
                            emojis: data.emojis || this.emojis,
                            emojiDescriptions: data.emojiDescriptions || '',
                            startHour: data.startHour ?? this.startHour,
                            showGoalsInTimeline: data.showGoalsInTimeline ?? false
                        });
                        
                        // For existing users who have data but no emoji descriptions yet,
                        // only set defaults if they're still using the old default emoji set
                        const oldDefaultEmojis = ['â˜•', 'ðŸ“–', 'ðŸ˜´', 'ðŸŽ®', 'ðŸ•', 'ðŸ’Š', 'ðŸŒ¿', 'ðŸ”´', 'ðŸŸ©', 'ðŸ“·'];
                        if (!this.emojiDescriptions && 
                            JSON.stringify(this.emojis) === JSON.stringify(oldDefaultEmojis)) {
                            
                            // Extract emojis from the descriptions and update the emoji array
                            const extractedEmojis = this.extractEmojis(this.emojiDescriptions);
                            if (extractedEmojis.length > 0) {
                                this.emojis = extractedEmojis;
                            }
                        }
                    } catch (e) {
                        console.warn("Failed to load saved data", e);
                    }
                } else {
                    this.createWelcomeMessage();
                }
            }

            createWelcomeMessage() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                const allWelcomeEntries = {
                    7: { emojis: ['ðŸ‘‹'], text: 'welcome to hourlies!' },
                    8: { emojis: ['ðŸ“Š'], text: 'see where your time really goes with minimal effort and zero guilt' },
                    
                    10: { emojis: ['âœï¸'], text: 'log what happened each hour, because honest data reveals real patterns' },
                    11: { emojis: ['âš™ï¸'], text: 'customize your emoji categories and set personal rules in Edit' },
                    12: { emojis: ['ðŸŽ¯'], text: 'your rules, your metrics. track what matters to you, not what others expect' },
                    
                    14: { emojis: ['ðŸ”'], text: 'goals compare your intentions against reality and show you the gaps' },
                    15: { emojis: ['ðŸ '], text: 'daily view gives you a visual overview of your whole day' },
                    16: { emojis: ['ðŸ—‘ï¸'], text: 'wipe button clears current day if you want to start fresh' },
                    
                    18: { emojis: ['ðŸ”„'], text: 'patterns over perfection. work with your reality instead of fighting it' },
                    19: { emojis: ['ðŸŒ™'], text: 'track honestly to enable self-discovery, improvement starts with awareness' },

                    21: { emojis: ['ðŸ”’'], text: 'everything is completely private and stays on your device' },
                    
                    23: { emojis: ['ðŸ“„'], text: isMobile ? 'long-tap an hour to copy' : 'right-click an hour to copy its entry' },
                    0: { emojis: ['ðŸ“„'], text: 'paste copied entries into empty hours' },
                    1: { emojis: ['âŒ¨ï¸'], text: isMobile ? '' : 'use arrow keys for quickly navigating between hours and days' },
                    2: { emojis: ['ðŸ“„'], text: 'if you make a mistake, you can undo it with the âŽŒ button in the header bar' },
                    };

                // Use effective date logic to determine proper calendar days for welcome messages
                const effectiveDate = this.getEffectiveDate();
                const currentDayKey = this.dateKey(effectiveDate);
                const nextDay = new Date(effectiveDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                
                // Ensure the days exist
                if (!this.allEntries[currentDayKey]) this.allEntries[currentDayKey] = {};
                if (!this.allEntries[nextDayKey]) this.allEntries[nextDayKey] = {};
                
                // Store entries in appropriate days with one loop
                Object.entries(allWelcomeEntries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });

                // Set default emoji categories on first launch
                if (!this.emojiDescriptions) {
                    this.emojiDescriptions = `Use these categories as base for your own personalized set.

ðŸ”µ Chores / errands â€” cleaning, shopping, cooking, transit  
ðŸŸ¡ Rest / fun â€” TV, games, downtime  
ðŸŸ¢ Work / projects â€” job tasks, creative work  
ðŸŸ£ Learning / study â€” courses, reading, practice

Everyday basics
ðŸ” Food
â˜• Caffeine / stimulants
ðŸ˜´ Sleep / nap
ðŸš¶ Movement / sports

Social & emotional
ðŸ’¬ Social
â™¥ï¸ Romance
ðŸ¥µ Stress

Extras
ðŸ“– Reading  
ðŸ‘¾ Gaming
ðŸ‘©â€ðŸ’» Coding / tech
â–¶ï¸ Youtube`;
                    
                    // Extract emojis from the descriptions and update the emoji array
                    const extractedEmojis = this.extractEmojis(this.emojiDescriptions);
                    if (extractedEmojis.length > 0) {
                        this.emojis = extractedEmojis;
                    }
                }

                // Add default rules if none exist
                if (!this.goals || this.goals.length === 0) {
                    this.goals = [
                        { id: Date.now() + 1, emojis: ['ðŸš¶'], operator: 'more_than', value: 0 }, // movement daily
                        { id: Date.now() + 2, emojis: ['ðŸ’¬'], operator: 'more_than', value: 0 }, // social connection daily  
                        { id: Date.now() + 3, emojis: ['ðŸ˜´'], operator: 'before', value: 1 }, // sleep before 1am
                        { id: Date.now() + 4, emojis: ['â˜•'], operator: 'more_than', value: 3, not: true }, // limit coffee
                    ];
                }
            }

            saveData() {
                localStorage.setItem("hourliesData", JSON.stringify({
                    allEntries: this.allEntries,
                    goals: this.goals,
                    emojis: this.emojis,
                    emojiDescriptions: this.emojiDescriptions,
                    startHour: this.startHour,
                    showGoalsInTimeline: this.showGoalsInTimeline
                }));
            }

            updateEntries(newEntries) {
                this.undoStack.push({ 
                    entries: { ...this.entries }, 
                    timestamp: Date.now(),
                    date: new Date(this.currentDate) // Store the date for undo
                });
                if (this.undoStack.length > 100) this.undoStack.shift();
                
                this.updateEntriesWithoutUndo(newEntries);
            }

            updateEntriesWithoutUndo(newEntries) {
                const { currentDayKey, nextDayKey } = this.ensureCalendarDaysExist();
                
                // Store entries in correct calendar days
                Object.entries(newEntries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        // Hours 7-23 go to current calendar day
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        // Hours 0-6 go to next calendar day
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });
                
                this.updateUndoButton();
                this.saveData();
            }

            // === UTILITIES ===
            dateKey(date) { return date ? date.toISOString().split('T')[0] : ''; }
            
            get currentDateKey() { 
                // For data storage, we need to account for hours that belong to previous day
                const effectiveDate = new Date(this.currentDate);
                return this.dateKey(effectiveDate);
            }
            
            get entries() { 
                const { currentDayEntries, nextDayEntries } = this.getCalendarDayEntries();
                const combinedEntries = {};
                
                // Add hours 7-23 from current calendar day
                for (let hour = this.startHour; hour < 24; hour++) {
                    if (currentDayEntries[hour]) {
                        combinedEntries[hour] = currentDayEntries[hour];
                    }
                }
                
                // Add hours 0-(startHour-1) from next calendar day
                for (let hour = 0; hour < this.startHour; hour++) {
                    if (nextDayEntries[hour]) {
                        combinedEntries[hour] = nextDayEntries[hour];
                    }
                }
                
                return combinedEntries;
            }
            
            get hours() { return Array.from({length: 24}, (_, i) => (this.startHour + i) % 24); }
            formatHour(hour) { return hour.toString().padStart(2, '0'); }
            
            // Helper methods for calendar day operations
            getCalendarDayKeys() {
                const currentDayKey = this.dateKey(this.currentDate);
                const nextDay = new Date(this.currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                return { currentDayKey, nextDayKey };
            }

            ensureCalendarDaysExist() {
                const { currentDayKey, nextDayKey } = this.getCalendarDayKeys();
                if (!this.allEntries[currentDayKey]) this.allEntries[currentDayKey] = {};
                if (!this.allEntries[nextDayKey]) this.allEntries[nextDayKey] = {};
                return { currentDayKey, nextDayKey };
            }

            getCalendarDayEntries() {
                const { currentDayKey, nextDayKey } = this.getCalendarDayKeys();
                return {
                    currentDayEntries: this.allEntries[currentDayKey] || {},
                    nextDayEntries: this.allEntries[nextDayKey] || {}
                };
            }

            clearCurrentDayEntries() {
                const { currentDayKey, nextDayKey } = this.getCalendarDayKeys();
                // Clear current entries
                if (this.allEntries[currentDayKey]) {
                    for (let hour = this.startHour; hour < 24; hour++) {
                        delete this.allEntries[currentDayKey][hour];
                    }
                }
                if (this.allEntries[nextDayKey]) {
                    for (let hour = 0; hour < this.startHour; hour++) {
                        delete this.allEntries[nextDayKey][hour];
                    }
                }
            }

            // Helper method for focusing textarea and setting cursor to end
            focusTextareaAtEnd(hour, delay = 0) {
                const focusAndSetCursor = () => {
                    const textarea = document.querySelector(`[data-hour="${hour}"] textarea`);
                    if (textarea) {
                        textarea.focus();
                        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                    }
                };
                
                if (delay > 0) {
                    setTimeout(focusAndSetCursor, delay);
                } else {
                    focusAndSetCursor();
                }
            }

            formatDateInput() {
                if (!this.currentDate) return '';
                return [
                    this.currentDate.getDate().toString().padStart(2, '0'),
                    (this.currentDate.getMonth() + 1).toString().padStart(2, '0'),
                    this.currentDate.getFullYear().toString().slice(-2)
                ].join('/');
            }

            getEffectiveDate() {
                // Get the current logical day based on start hour
                const d = new Date(this.currentTime);
                if (d.getHours() < this.startHour) {
                    d.setDate(d.getDate() - 1);
                }
                return d;
            }

            compareDateToToday() {
                const todayKey = this.dateKey(this.getEffectiveDate());
                const currentKey = this.currentDateKey;
                if (currentKey === todayKey) return 0;  // current
                return currentKey < todayKey ? -1 : 1;   // past : future
            }

            isCurrentDate() { return this.compareDateToToday() === 0; }
            isPastDate() { return this.compareDateToToday() < 0; }
            isFutureDate() { return this.compareDateToToday() > 0; }

            getHourFill(hour) {
                // Skip fill logic if not on current day
                if (!this.isCurrentDate()) {
                    if (this.isPastDate()) return 100;
                    return 0;
                }

                const currentHour = this.currentTime.getHours();
                const adjustedHour = hour < this.startHour ? hour + 24 : hour;
                const adjustedCurrentHour = currentHour < this.startHour ? currentHour + 24 : currentHour;
                
                if (adjustedHour < adjustedCurrentHour) return 100;
                if (adjustedHour === adjustedCurrentHour) return (this.currentTime.getMinutes() / 60) * 100;
                return 0;
            }

            isCurrentHour(hour) {
                return this.isCurrentDate() && this.currentTime.getHours() === hour;
            }

            // === EVENTS ===
            setupEvents() {
                // Global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in input fields
                    if (e.target.matches('input, textarea')) return;
                    
                    // Don't trigger when editing an hour
                    if (this.editingHour !== null) return;
                    
                    switch (e.key.toLowerCase()) {
                        case 'arrowleft':
                            this.navigateDay(-1);
                            e.preventDefault();
                            break;
                        case 'arrowright':
                            this.navigateDay(1);
                            e.preventDefault();
                            break;
                        case 'f':
                            document.querySelector('.date-input')?.focus();
                            e.preventDefault();
                            break;
                        case 'e':
                            this.setView('settings');
                            e.preventDefault();
                            break;
                        case 'd':
                            this.setView('daily');
                            e.preventDefault();
                            break;
                        case 'h':
                            this.setView('timeline');
                            e.preventDefault();
                            break;
                    }
                });
                
                // Handle backspace/delete on hover
                document.addEventListener('keydown', (e) => {
                    if ((e.key === 'Backspace' || e.key === 'Delete') && 
                        this.editingHour === null && // Not in edit mode
                        this.hoveredHour !== null && // Hovering over an entry
                        this.view === 'timeline' && // In timeline view
                        !e.target.matches('input, textarea')) { // Not typing in an input
                        this.clearEntry(this.hoveredHour);
                        e.preventDefault(); // Prevent browser back navigation
                    }
                });

                document.addEventListener('click', (e) => {
                    if (this.editingHour === null) return;
                    const isInterface = e.target.classList.contains('app-overlay') ||
                                      e.target.classList.contains('hour-input') ||
                                      e.target.classList.contains('clear-btn') ||
                                      e.target.classList.contains('emoji-btn');
                    if (!isInterface) {
                        e.preventDefault();
                        this.focusTextareaAtEnd(this.editingHour, 0);
                    }
                });
            }

            // === NAVIGATION ===
            navigateDay(direction) {
                this.finishEditing();
                this.currentDate.setDate(this.currentDate.getDate() + direction);
                this.render();
            }

            jumpToToday() {
                this.finishEditing();
                this.currentDate = this.getEffectiveDate();
                this.render();
                setTimeout(() => this.scrollToCurrentHour(), 100);
            }

            setView(view) {
                if (this.view === 'timeline' && view !== 'timeline') {
                    const container = document.querySelector('.daily-container');
                    if (container) this.timelineScrollPosition = container.scrollTop;
                }

                this.finishEditing();
                this.view = view;
                this.editingGoal = null;
                this.updateHeaderTitle();
                this.render();
            }

            updateHeaderTitle() {
                const floatingNavDate = document.getElementById('floatingNavDate');
                if (!floatingNavDate) return;

                if (this.view === 'timeline') {
                    floatingNavDate.textContent = "hourlies";
                    floatingNavDate.classList.add('btn-active');
                } else {
                    floatingNavDate.textContent = "â† " + this.formatNavbarDate(this.currentDate).toLowerCase();
                    floatingNavDate.classList.remove('btn-active');

                        floatingNavDate.onclick = () => app.setView('timeline');
                }
            }

            handleScroll(e) {
                const scrolled = e.target.scrollTop > 150;
                const floatingNavDate = document.getElementById('floatingNavDate');
                
                if (floatingNavDate) {
                    if (this.view === 'timeline') {
                        if (scrolled) {
                            floatingNavDate.textContent = this.formatNavbarDate(this.currentDate).toLowerCase();
                            floatingNavDate.onclick = () => {
                                document.getElementById('mainContainer').scrollTo({ top: 0, behavior: 'smooth' });
                            };
                        } else {
                            floatingNavDate.textContent = "hourlies";
                            floatingNavDate.onclick = () => app.setView('timeline');
                        }
                        floatingNavDate.classList.add('btn-active');
                    } else {
                        floatingNavDate.textContent = "â† " + this.formatNavbarDate(this.currentDate).toLowerCase();
                        floatingNavDate.classList.remove('btn-active');
                        floatingNavDate.onclick = () => app.setView('timeline');
                    }
                }
            }

            // === DATE INPUT ===
            handleDateInput(event) {
                const value = event.target.value.replace(/\D/g, '');
                event.target.value = value.match(/.{1,2}/g)?.join('/') || value;

                const parseAndSetDate = (value, useCurrentYear = false) => {
                    const day = parseInt(value.slice(0, 2), 10);
                    const month = parseInt(value.slice(2, 4), 10) - 1;
                    const year = useCurrentYear ? this.currentTime.getFullYear() : 2000 + parseInt(value.slice(4, 6), 10);

                    // Set currentDate and currentTime to the user's entered date
                    const inputDate = new Date(year, month, day, 12, 0, 0);

                    if (!isNaN(inputDate.getTime()) && day > 0 && day <= 31 && month >= 0 && month < 12) {
                        this.currentDate = new Date(year, month, day);
                        this.currentTime = new Date(year, month, day, 12, 0, 0);
                        event.target.value = this.formatDateInput();
                        this.render();
                        return true;
                    }
                    return false;
                };

                if (value.length === 4 && (event.type === 'blur' || event.key === 'Enter')) {
                    if (!parseAndSetDate(value, true)) {
                        event.target.value = this.formatDateInput();
                    }
                } else if (value.length === 6) {
                    parseAndSetDate(value);
                }
            }

            formatNavbarDate(date) {
                return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }).toLowerCase();
            }

            handleDateKeydown(event) {
                const allowed = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Escape'];
                if (!/^\d$/.test(event.key) && !allowed.includes(event.key)) {
                    event.preventDefault();
                }
                if (event.key === 'Enter') {
                    event.preventDefault();
                    event.target.blur();
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    event.target.value = this.formatDateInput();
                    event.target.blur();
                }
            }

            handleDateFocus(event) {
                event.target.select();
                event.target.addEventListener('blur', (e) => this.handleDateInput(e), { once: true });
            }

            // === HOURS ===
            editHour(hour) {
                if (this.editingHour === hour) return;
                
                // Finish any current editing session
                this.finishEditing();
                
                // Save state when starting to edit (before any changes)
                this.editStartState = { ...this.entries };
                this.editingHour = hour;
                this.renderHours();
                
                setTimeout(() => {
                    const hourElement = document.querySelector(`[data-hour="${hour}"]`);
                    const textarea = hourElement?.querySelector('textarea');
                    if (textarea) {
                        if (window.innerWidth <= 768) {
                            const container = document.querySelector('.scroll-container');
                            const containerRect = container.getBoundingClientRect();
                            const elementRect = hourElement.getBoundingClientRect();
                            const relativeTop = elementRect.top - containerRect.top;
                            const targetPosition = containerRect.height * 0.15;
                            container.scrollTop = container.scrollTop + (relativeTop - targetPosition);
                        } else {
                            hourElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        
                        this.focusTextareaAtEnd(hour, 100);
                    }
                }, 30);
            }

            updateText(text) {
                const entry = this.entries[this.editingHour] || { emojis: [], text: '' };
                const newEntries = { ...this.entries };
                newEntries[this.editingHour] = { ...entry, text };
                
                // Update entries without adding to undo stack (we'll do that on edit completion)
                this.updateEntriesWithoutUndo(newEntries);
            }

            finishEditing() {
                if (this.editingHour === null) return;
                
                // Add undo entry for the entire edit session
                if (this.editStartState) {
                    // Check if anything actually changed
                    const currentEntries = { ...this.entries };
                    const hasChanges = JSON.stringify(this.editStartState) !== JSON.stringify(currentEntries);
                    
                    if (hasChanges) {
                        this.undoStack.push({ 
                            entries: { ...this.editStartState }, 
                            timestamp: Date.now(),
                            date: new Date(this.currentDate)
                        });
                        if (this.undoStack.length > 100) this.undoStack.shift();
                    }
                    
                    this.editStartState = null;
                }
                
                this.editingHour = null;
                this.renderHours();
            }

            clearEntry(hour) {
                // If we're clearing the currently edited hour, finish editing first
                if (this.editingHour === hour) {
                    this.finishEditing();
                }
                
                const newEntries = { ...this.entries };
                newEntries[hour] = { emojis: [], text: '' };
                this.updateEntries(newEntries);
                this.renderHours();
            }

            toggleEmoji(emoji) {
                const entry = this.entries[this.editingHour] || { emojis: [], text: '' };
                const validEmojis = entry.emojis.filter(e => this.emojis.includes(e));
                const newEmojis = validEmojis.includes(emoji)
                    ? validEmojis.filter(e => e !== emoji)
                    : [...validEmojis, emoji];
                const newEntries = { ...this.entries };
                newEntries[this.editingHour] = { ...entry, emojis: newEmojis };
                
                // Update entries without adding to undo stack (we'll do that on edit completion)
                this.updateEntriesWithoutUndo(newEntries);
                this.renderHours();
                this.renderGoals();
                this.focusTextareaAtEnd(this.editingHour, 50);
            }

            handleHourInputKeydown(event, hour) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.finishEditing();
                } else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    const textarea = event.target;
                    const cursorAtEnd = textarea.selectionStart === textarea.value.length;
                    
                    // Only navigate if cursor is at the very end of the text
                    if (cursorAtEnd) {
                        event.preventDefault();
                        const currentIndex = this.hours.indexOf(hour);
                        const nextIndex = event.key === 'ArrowUp' 
                            ? (currentIndex - 1 + this.hours.length) % this.hours.length
                            : (currentIndex + 1) % this.hours.length;
                        const nextHour = this.hours[nextIndex];

                        // Finish current edit before moving to next
                        this.finishEditing();
                        
                        // Start editing the next hour
                        this.editStartState = { ...this.entries };
                        this.editingHour = nextHour;
                        this.renderHours();
                        
                        this.focusTextareaAtEnd(nextHour, 0);
                    }
                }
            }

            // === COPY/PASTE ===
            handleCopyPaste(hour, entry, element) {
                const hasContent = (entry.text && entry.text.trim()) || (entry.emojis && entry.emojis.length > 0);

                if (hasContent) {
                    this.clipboardEntry = {
                        emojis: entry.emojis ? [...entry.emojis] : [],
                        text: entry.text || ""
                    };
                    element.classList.add("flash");
                    setTimeout(() => element.classList.remove("flash"), 500);
                } else if (this.clipboardEntry) {
                    const newEntries = { ...this.entries };
                    newEntries[hour] = { ...this.clipboardEntry };
                    this.updateEntries(newEntries);
                    this.renderHours();
                }
            }

            attachCopyPasteEvents() {
                document.querySelectorAll(".hour-entry").forEach(el => {
                    const hour = parseInt(el.dataset.hour);
                    const entry = this.entries[hour] || { emojis: [], text: "" };

                    el.addEventListener("mouseenter", () => {
                        this.hoveredHour = hour;
                    });

                    el.addEventListener("mouseleave", () => {
                        this.hoveredHour = null;
                    });

                    el.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        this.handleCopyPaste(hour, entry, el);
                    });

                    let longPressTimer;
                    el.addEventListener("touchstart", () => {
                        longPressTimer = setTimeout(() => {
                            this.handleCopyPaste(hour, entry, el);
                            el._suppressClick = true;
                        }, 500);
                    });
                    
                    el.addEventListener("touchend", () => clearTimeout(longPressTimer));
                    el.addEventListener("touchmove", () => clearTimeout(longPressTimer));

                    el.addEventListener("click", (e) => {
                        if (el._suppressClick) {
                            e.stopImmediatePropagation();
                            el._suppressClick = false;
                        }
                    }, true);
                });
            }

            // === GOALS ===
            addGoal() {
                const newGoal = {
                    id: Date.now(),
                    emojis: ['ðŸ“–'],
                    operator: 'more_than',
                    value: 1
                };
                this.goals.push(newGoal);
                this.renderSettings();
            }

            updateGoal(id, updates) {
                this.goals = this.goals.map(goal => goal.id === id ? { ...goal, ...updates } : goal);
                this.saveData();
                this.renderSettings();
            }

            removeGoal(id) {
                this.goals = this.goals.filter(goal => goal.id !== id);
                this.saveData();
                this.renderSettings();
            }

            editGoal(id) {
                const wasEditing = this.editingGoal === id;
                this.editingGoal = this.editingGoal === id ? null : id;
                this.renderSettings();
            }

            cycleOperator(goalId) {
                const goal = this.goals.find(g => g.id === goalId);
                const operators = ['more_than', 'less_than', 'before', 'after'];
                const currentIndex = operators.indexOf(goal.operator);
                const nextIndex = (currentIndex + 1) % operators.length;
                this.updateGoal(goalId, { operator: operators[nextIndex] });
            }

            formatGoalText(goal) {
                const opText = goal.operator.replace('_', ' ');
                const suffix = goal.operator.includes('than') ? ' times' : '';
                const negation = goal.not ? 'not ' : '';
                const emojiText = Array.isArray(goal.emojis) ? goal.emojis.join(' ') : goal.emoji;
                return `${negation}${emojiText} ${opText} ${goal.value}${suffix}`;
            }

            checkGoals() {
                const dayEntries = Object.values(this.entries);
                return this.goals.map(goal => {
                    const emojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                    // Count total appearances of any emoji in the rule
                    const emojiCount = dayEntries.reduce((count, entry) => {
                        return count + emojis.reduce((c, emoji) => c + (entry.emojis?.filter(e => e === emoji).length || 0), 0);
                    }, 0);
                    // Find all hours where any emoji in the rule appears
                    const emojiHours = Object.keys(this.entries).filter(hour => {
                        const entryEmojis = this.entries[hour].emojis || [];
                        return emojis.some(emoji => entryEmojis.includes(emoji));
                    }).map(Number);
                    let met = false;
                    if (goal.operator === 'more_than') {
                        met = emojiCount > goal.value;
                    } else if (goal.operator === 'less_than') {
                        met = emojiCount < goal.value;
                    } else if (goal.operator === 'before' && emojiHours.length > 0) {
                        const adjustedHours = emojiHours.map(h => h < this.startHour ? h + 24 : h);
                        const adjustedTarget = goal.value < this.startHour ? goal.value + 24 : goal.value;
                        met = Math.min(...adjustedHours) < adjustedTarget;
                    } else if (goal.operator === 'after' && emojiHours.length > 0) {
                        const adjustedHours = emojiHours.map(h => h < this.startHour ? h + 24 : h);
                        const adjustedTarget = goal.value < this.startHour ? goal.value + 24 : goal.value;
                        met = Math.max(...adjustedHours) > adjustedTarget;
                    }
                    if (goal.not) met = !met;
                    return { ...goal, met, emojiCount };
                });
            }

            // === TIMER ===
            startTimer() {
                setInterval(() => {
                    this.currentTime = new Date();
                    
                    // Only update the UI if we're on the current day and in timeline view
                    if (this.isCurrentDate() && this.view === 'timeline' && this.editingHour === null) {
                        this.renderHours();
                    }
                }, 60000);
            }

            undo() {
                if (this.undoStack.length === 0) return;
                const lastState = this.undoStack.pop();
                
                // Restore the date from the undo state
                if (lastState.date) {
                    this.currentDate = new Date(lastState.date);
                }
                
                // Clear current entries and restore from undo state
                this.clearCurrentDayEntries();
                const { currentDayKey, nextDayKey } = this.ensureCalendarDaysExist();
                
                // Restore entries using same logic as updateEntriesWithoutUndo
                Object.entries(lastState.entries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });
                
                this.updateUndoButton();
                this.renderHours();
                this.saveData();
            }

            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.style.display = this.view === 'timeline' && this.undoStack.length > 0 ? 'block' : 'none';
                }
            }

            scrollToCurrentHour() {
                const container = document.querySelector('.scroll-container');
                if (!container) return;
                const currentHourIndex = this.hours.findIndex(hour => hour === this.currentTime.getHours());
                if (currentHourIndex === -1) return;
                const hourElements = container.querySelectorAll('[data-hour]');
                const targetElement = hourElements[currentHourIndex];
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            // === EXPORT ===
            exportCurrentDayJSON() {
                const currentDayData = {
                    date: this.currentDateKey,
                    entries: this.entries,
                    timestamp: new Date().toISOString()
                };
                
                const content = JSON.stringify(currentDayData, null, 2);
                
                try {
                    navigator.clipboard.writeText(content);
                } catch (err) {
                    const blob = new Blob([content], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hourlies-${this.formatDateInput()}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            groupEntriesByMonth() {
                const months = {};
                Object.entries(this.allEntries).forEach(([dateKey, entries]) => {
                    const [year, month] = dateKey.split('-');
                    const monthKey = `${year}-${month}`;
                    if (!months[monthKey]) months[monthKey] = {};
                    months[monthKey][dateKey] = entries;
                });
                return months;
            }

            exportAllToJSON() {
                const exportData = {
                    version: 2,
                    timestamp: new Date().toISOString(),
                    settings: {
                        emojis: this.emojis,
                        emojiDescriptions: this.emojiDescriptions,
                        startHour: this.startHour,
                        showGoalsInTimeline: this.showGoalsInTimeline
                    },
                    goals: this.goals.map(goal => ({
                        ...goal,
                        emojis: Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji]
                    })),
                    entries: this.allEntries
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const timestamp = new Date().toISOString().split('T')[0];
                a.href = url;
                a.download = `hourlies-export-${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            importFromJSONFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        console.log('Importing data:', importData);
                        
                        if (importData.version === 2) {
                            // New complete export format
                            if (importData.settings) {
                                if (Array.isArray(importData.settings.emojis)) {
                                    this.emojis = [...importData.settings.emojis];
                                }
                                if (importData.settings.emojiDescriptions) {
                                    this.emojiDescriptions = importData.settings.emojiDescriptions;
                                }
                                if (typeof importData.settings.startHour === 'number' && 
                                    importData.settings.startHour >= 0 && 
                                    importData.settings.startHour < 24) {
                                    this.startHour = importData.settings.startHour;
                                }
                                if (typeof importData.settings.showGoalsInTimeline === 'boolean') {
                                    this.showGoalsInTimeline = Boolean(importData.settings.showGoalsInTimeline);
                                }
                            }
                            if (Array.isArray(importData.goals)) {
                                this.goals = importData.goals.filter(goal => {
                                    const validOperators = ['more_than', 'less_than', 'before', 'after'];
                                    return goal && 
                                           goal.id && 
                                           Array.isArray(goal.emojis) && 
                                           validOperators.includes(goal.operator) && 
                                           typeof goal.value === 'number';
                                }).map(goal => ({
                                    ...goal,
                                    not: Boolean(goal.not),
                                    value: Math.max(0, Math.min(23, goal.value))
                                }));
                            }
                            if (importData.entries && typeof importData.entries === 'object') {
                                // Import all entries
                                this.allEntries = { ...this.allEntries, ...importData.entries };
                            }
                        } else if (importData.version === 1) {
                            // Old settings-only format for backward compatibility
                            if (importData.settings) {
                                if (Array.isArray(importData.settings.emojis)) {
                                    this.emojis = [...importData.settings.emojis];
                                }
                                if (typeof importData.settings.startHour === 'number' && 
                                    importData.settings.startHour >= 0 && 
                                    importData.settings.startHour < 24) {
                                    this.startHour = importData.settings.startHour;
                                }
                                if (typeof importData.settings.showGoalsInTimeline === 'boolean') {
                                    this.showGoalsInTimeline = Boolean(importData.settings.showGoalsInTimeline);
                                }
                            }
                            if (Array.isArray(importData.rules)) {
                                const validOperators = ['more_than', 'less_than', 'before', 'after'];
                                this.goals = importData.rules.filter(goal => {
                                    return goal && 
                                           goal.id && 
                                           Array.isArray(goal.emojis) && 
                                           validOperators.includes(goal.operator) && 
                                           typeof goal.value === 'number';
                                }).map(goal => ({
                                    ...goal,
                                    not: Boolean(goal.not),
                                    value: Math.max(0, Math.min(23, goal.value))
                                }));
                            }
                        } else if (importData.date && importData.entries) {
                            // Single day export format
                            this.allEntries[importData.date] = importData.entries;
                        } else {
                            // Legacy format for backward compatibility
                            if (Array.isArray(importData.emojis)) {
                                this.emojis = [...importData.emojis].filter(emoji => /\p{Emoji}/u.test(emoji));
                            }
                            if (Array.isArray(importData.goals)) {
                                this.goals = importData.goals.map(goal => {
                                    if (goal.emoji && !goal.emojis) {
                                        goal.emojis = [goal.emoji];
                                        delete goal.emoji;
                                    }
                                    return goal;
                                });
                            }
                            if (typeof importData.startHour === 'number' && 
                                importData.startHour >= 0 && 
                                importData.startHour < 24) {
                                this.startHour = importData.startHour;
                            }
                            if (typeof importData.showGoalsInTimeline === 'boolean') {
                                this.showGoalsInTimeline = Boolean(importData.showGoalsInTimeline);
                            }
                        }
                        
                        this.saveData();
                        this.render();
                        alert('Data imported successfully');
                    } catch (err) {
                        console.error('Import error:', err);
                        alert('Error importing data: Invalid JSON file');
                    }
                };

                reader.readAsText(file);
            }

            wipeCurrentDayData() {
                this.clearCurrentDayEntries();
                this.render();
                this.saveData();
            }

            startBubbleAnimation() {
                // Clean up any existing animation
                if (this.bubbleAnimationId) {
                    cancelAnimationFrame(this.bubbleAnimationId);
                    this.bubbleAnimationId = null;
                }

                const container = document.querySelector('.bubbles-container');
                if (!container) return;
                const bubbles = container.querySelectorAll('.bubble');
                const containerRect = container.getBoundingClientRect();
                const bubbleStates = new Map();
                
                // Physics constants
                const centerGravity = 0.015;
                const friction = 0.995;
                const restitution = 0.3;
                const repulsion = 2.0;
                const maxSpeed = 1;
                const minSpeed = 0;
                const gravityDampening = 0.7;

                // Initialize bubbles randomly across the entire container
                // Initialize bubbles with no overlaps
                bubbles.forEach((bubble) => {
                    const size = parseFloat(bubble.style.width);
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;
                    const padding = size;
                    
                    let attempts = 0;
                    let pixelX, pixelY;
                    let overlap;
                    
                    // Try to find non-overlapping position
                    do {
                        pixelX = padding + Math.random() * (containerWidth - size - padding * 2);
                        pixelY = padding + Math.random() * (containerHeight - size - padding * 2);
                        
                        overlap = false;
                        // Check against all existing bubbles
                        bubbleStates.forEach((existingState) => {
                            const dx = (pixelX + size/2) - (existingState.x + existingState.size/2);
                            const dy = (pixelY + size/2) - (existingState.y + existingState.size/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < (size + existingState.size) / 2) {
                                overlap = true;
                            }
                        });
                        attempts++;
                    } while (overlap && attempts < 100); // Prevent infinite loop
                    
                    // Initial velocity with random direction
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 0.5 + 0.5; // 0.5-1.0 base speed
                    const initialVelX = Math.cos(angle) * speed;
                    const initialVelY = Math.sin(angle) * speed;
                
                bubbleStates.set(bubble, {
                    x: pixelX,
                    y: pixelY,
                    vx: initialVelX === 0 ? 0.1 : initialVelX, // Ensure non-zero initial velocity
                    vy: initialVelY === 0 ? 0.1 : initialVelY,
                    size: size,
                });
                });

                let lastFrame = performance.now();
                const animate = (currentTime) => {
                    if (!document.querySelector('.bubbles-container')) {
                        cancelAnimationFrame(this.bubbleAnimationId);
                        this.bubbleAnimationId = null;
                        return; // Stop if container is gone
                    }

                    const deltaTime = Math.min(currentTime - lastFrame, 32); // Cap at ~30fps
                    lastFrame = currentTime;

                    // Apply forces and update positions
                    bubbleStates.forEach((state, bubble) => {
                        // Use mouse position as gravity center when hovering
                        const bubbleCenterX = state.x + state.size / 2;
                        const bubbleCenterY = state.y + state.size / 2;
                        const containerRadius = Math.min(containerRect.width, containerRect.height) / 2;
                        
                        // Default to container center if mouse is not over container
                        const containerCenterX = this.mouseX || containerRect.width / 2;
                        const containerCenterY = this.mouseY || containerRect.height / 2;

                        // Calculate gravity/repulsion with improved stability
                        const dx = containerCenterX - bubbleCenterX;
                        const dy = containerCenterY - bubbleCenterY;
                        const distToCenter = Math.sqrt(dx * dx + dy * dy);
                        if (distToCenter > 0) {
                            // Calculate normalized direction
                            const dirX = dx / distToCenter;
                            const dirY = dy / distToCenter;
                            
                            // Calculate force strength with smooth falloff
                            const normalizedDist = Math.min(distToCenter / containerRadius, 1);
                            let forceStrength;
                            
                            // Repel if mouse is over container, attract otherwise
                            if (this.mouseX != null && this.mouseY != null) {
                                // Stronger repulsion when closer to mouse
                                forceStrength = -centerGravity * 15 * (1 - Math.pow(normalizedDist, 0.8));
                            } else {
                                // Normal center attraction when no mouse
                                forceStrength = centerGravity * 0.7 * Math.pow(normalizedDist, 1.2);
                            }
                            
                            // Apply force with dampening based on current velocity
                            const currentSpeed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                            const dampening = Math.max(0, 1 - (currentSpeed / maxSpeed) * gravityDampening);
                            
                            state.vx += dirX * forceStrength * dampening;
                            state.vy += dirY * forceStrength * dampening;
                        }

                        // Apply friction
                        state.vx *= friction;
                        state.vy *= friction;

                        // Maintain minimum and maximum speed
                        const speed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                        if (speed < minSpeed) {
                            const scale = minSpeed / speed;
                            state.vx *= scale;
                            state.vy *= scale;
                        } else if (speed > maxSpeed) {
                            const scale = maxSpeed / speed;
                            state.vx *= scale;
                            state.vy *= scale;
                        }

                        // Update position
                        state.x += state.vx;
                        state.y += state.vy;

                        // Bounce off container bounds (rectangular boundary)
                        const radius = state.size / 2;
                        
                        // Right wall
                        if (state.x + state.size > containerRect.width) {
                            state.x = containerRect.width - state.size;
                            state.vx *= -restitution;
                        }
                        // Left wall
                        if (state.x < 0) {
                            state.x = 0;
                            state.vx *= -restitution;
                        }
                        // Bottom wall
                        if (state.y + state.size > containerRect.height) {
                            state.y = containerRect.height - state.size;
                            state.vy *= -restitution;
                        }
                        // Top wall
                        if (state.y < 0) {
                            state.y = 0;
                            state.vy *= -restitution;
                        }

                        const newX = (state.x / containerRect.width) * 100;
                        const newY = (state.y / containerRect.height) * 100;
                        
                        if (Math.abs(parseFloat(bubble.style.left) - newX) > 0.01 ||
                            Math.abs(parseFloat(bubble.style.top) - newY) > 0.01) {
                            bubble.style.left = `${newX}%`;
                            bubble.style.top = `${newY}%`;
                        }
                    });

                    // Handle collisions between bubbles
                    const bubbleArray = Array.from(bubbleStates.entries());
                    for (let i = 0; i < bubbleArray.length; i++) {
                        const [bubble1, state1] = bubbleArray[i];
                        for (let j = i + 1; j < bubbleArray.length; j++) {
                            const [bubble2, state2] = bubbleArray[j];
                            
                            // Calculate centers
                            const center1X = state1.x + state1.size / 2;
                            const center1Y = state1.y + state1.size / 2;
                            const center2X = state2.x + state2.size / 2;
                            const center2Y = state2.y + state2.size / 2;
                            
                            // Check collision
                            const dx = center2X - center1X;
                            const dy = center2Y - center1Y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDist = (state1.size + state2.size) / 2;

                            if (distance < minDist) {
                                // Normalize collision vector
                                const nx = dx / distance;
                                const ny = dy / distance;
                                
                                const relativeVelX = state2.vx - state1.vx;
                                const relativeVelY = state2.vy - state1.vy;
                                
                                const relativeSpeed = relativeVelX * nx + relativeVelY * ny;
                                
                                if (relativeSpeed > 0) continue;
                                
                                const overlap = minDist - distance;
                                state1.x -= nx * overlap * 0.5;
                                state1.y -= ny * overlap * 0.5;
                                state2.x += nx * overlap * 0.5;
                                state2.y += ny * overlap * 0.5;
                                
                                const repulsionForce = repulsion * Math.min(1.0, overlap / minDist);
                                state1.vx -= nx * repulsionForce;
                                state1.vy -= ny * repulsionForce;
                                state2.vx += nx * repulsionForce;
                                state2.vy += ny * repulsionForce;
                            }
                        }
                    }

                    this.bubbleAnimationId = requestAnimationFrame(animate);
                };
                
                this.bubbleAnimationId = requestAnimationFrame(animate);

                // Track mouse position using event delegation
                container.addEventListener('mouseenter', (e) => {
                    const bubble = e.target.closest('.bubble');
                    if (bubble) {
                        const rect = container.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                    }
                });

                container.addEventListener('mousemove', (e) => {
                    const bubble = e.target.closest('.bubble');
                    if (bubble) {
                        const rect = container.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                    }
                });

                container.addEventListener('mouseout', (e) => {
                    const bubble = e.target.closest('.bubble');
                    const relatedBubble = e.relatedTarget?.closest('.bubble');
                    if (bubble && !relatedBubble) {
                        this.mouseX = null;
                        this.mouseY = null;
                    }
                });

                // Handle window resize
                this.resizeObserver?.disconnect();
                this.resizeObserver = new ResizeObserver(() => {
                    // Recalculate container dimensions
                    const newRect = container.getBoundingClientRect();
                    const scaleX = newRect.width / containerRect.width;
                    const scaleY = newRect.height / containerRect.height;
                    
                    // Scale bubble positions to new container size
                    bubbleStates.forEach((state, bubble) => {
                        state.x *= scaleX;
                        state.y *= scaleY;
                    });
                    
                    // Update container rect reference
                    Object.assign(containerRect, newRect);
                });
            }

            // === RENDER ===
            render() {
                this.updateUndoButton();
                this.checkGoals(); // Always update/check dailies on UI update

                if (this.view === 'timeline') {
                    this.renderTimeline();
                } else if (this.view === 'settings') {
                    this.renderSettings();
                } else if (this.view === 'daily') {
                    this.renderDaily();
                }
            }

            renderTimeline() {
                document.getElementById('mainContainer').innerHTML = `
                    <div class="scroll-container">
                        <div class="date-nav">
                            <div class="date-nav-left">
                                <div class="date-btn" onclick="app.navigateDay(-1)" title="Previous day (Left Arrow)">â†</div>
                                <input type="text" 
                                    class="date-input secondary-btn"
                                    value="${this.formatDateInput()}"
                                    maxlength="8"
                                    onkeydown="app.handleDateKeydown(event)"
                                    oninput="app.handleDateInput(event)"
                                    onfocus="app.handleDateFocus(event)"
                                    title="Focus date input (Press 'F')">
                                <div class="date-btn" onclick="app.navigateDay(1)" title="Next day (Right Arrow)">â†’</div>
                            </div>
                            <div class="date-nav-right">
                                <div onclick="app.jumpToToday()" title="Return to current day">jump to now</div>
                            </div>
                        </div>
                        <div id="goalsSection"></div>
                        <div id="hoursContainer"></div>
                    </div>
                    <div class="scroll-bar ${this.editingHour !== null ? 'hidden' : ''}" id="customScrollBar"></div>
                `;

                const container = document.querySelector('.main-container');
                container.addEventListener('scroll', this.handleScroll.bind(this));
                if (this.timelineScrollPosition > 0) {
                    container.scrollTop = this.timelineScrollPosition;
                }

                // Custom scrollbar logic
                const scrollBar = document.getElementById('customScrollBar');
                let isDragging = false;
                let startY = 0;
                let startScroll = 0;

                scrollBar.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startScroll = container.scrollTop;
                    scrollBar.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaY = e.clientY - startY;
                    container.scrollTop = startScroll - deltaY * 2; // inverted direction, 2x impact
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        scrollBar.classList.remove('dragging');
                        document.body.style.userSelect = '';
                    }
                });

                // Double click to jump to now
                scrollBar.addEventListener('dblclick', () => {
                    app.jumpToToday();
                });

                this.renderGoals();
                this.renderHours();
            }

            renderGoals() {
                const goalsSection = document.getElementById('goalsSection');
                if (!goalsSection) return;
                
                const goalChecks = this.checkGoals();

                if (this.goals.length > 0 && this.showGoalsInTimeline) {
                    goalsSection.innerHTML = `
                        <div class="goals-section">
                            ${goalChecks.map(goal => `
                                <div class="goal-item ${goal.met ? 'passed' : 'failed'}">
                                    <span class="goal-text">${this.formatGoalText(goal)}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else if (this.goals.length === 0 && this.showGoalsInTimeline) {
                    goalsSection.innerHTML = '<div class="no-goals">no dailies set - add in settings</div>';
                } else {
                    goalsSection.innerHTML = '';
                }
            }

            renderHours() {
                this.saveData();
                const hoursContainer = document.getElementById('hoursContainer');
                if (!hoursContainer) return;
                
                hoursContainer.innerHTML = `
                    <div class="hours-container">
                        ${this.hours.map(hour => {
                            const entry = this.entries[hour] || { emojis: [], text: '' };
                            const isCurrent = this.isCurrentHour(hour);
                            const isEditing = this.editingHour === hour;
                            const hourFill = this.getHourFill(hour);
                            // Show all emojis if there's no text, otherwise limit to 6
                            const emojis = (entry.emojis || []).slice(0, entry.text ? 6 : undefined);

                            return `
                                <div class="hour-row">
                                    ${isEditing ? `
                                        <div class="emoji-picker below">
                                            ${this.emojis.map(emoji => `
                                                <button class="emoji-btn ${entry.emojis?.includes(emoji) ? 'selected' : ''}"
                                                        onclick="app.toggleEmoji('${emoji}')">
                                                    ${emoji}
                                                </button>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="hour-entry ${isCurrent ? 'current' : ''} ${isEditing ? 'editing' : ''}"
                                         data-hour="${hour}"
                                         onclick="app.editHour(${hour})">
                                        ${hourFill > 0 ? `<div class="hour-fill ${!entry.text && !entry.emojis?.length ? 'empty' : ''}" style="width: ${hourFill}%;"></div>` : ''}
                                        <div class="hour-content">
                                            <span class="hour-time">${this.formatHour(hour)}</span>
                                            <div class="hour-emojis">
                                                ${emojis.map(emoji => `<span class="emoji">${emoji}</span>`).join('')}
                                            </div>
                                            ${isEditing ? `
                                                <div class="hour-input-container">
                                                    <textarea class="hour-input"
                                                           placeholder="${this.isFutureDate() ? 'Plan ahead...' : this.isPastDate() ? 'Remember...' : 'What happened?'}"
                                                           oninput="app.updateText(this.value)"
                                                           onkeydown="app.handleHourInputKeydown(event, ${hour})"
                                                           onclick="event.stopPropagation()">${entry.text}</textarea>
                                                    <button class="clear-btn" onclick="event.stopPropagation(); app.clearEntry(${hour})">Ã—</button>
                                                </div>
                                            ` : `<span class="hour-text">${entry.text.replace(/\n/g, '<br>')}</span>`}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        ${this.editingHour !== null ? '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 500;" onclick="app.finishEditing()"></div>' : ''}
                    </div>
                `;
                this.attachCopyPasteEvents();
            }

            renderSettings() {
                document.getElementById('mainContainer').innerHTML = `
                    <div class="settings-container">
                        <div class="setting-group">
                            <label class="setting-label">Available Emojis</label>
                            <textarea class="setting-input emoji-input" 
                                onfocus="this.style.position='fixed'; this.style.top='50%'; this.style.left='50%'; this.style.transform='translate(-50%, -50%)'; this.style.zIndex='1000'; this.style.width='80%'; this.style.maxWidth='80%'; this.style.height='80vh';"
                                onblur="app.handleEmojiInput(this.value); this.style.position=''; this.style.top=''; this.style.left=''; this.style.transform=''; this.style.zIndex=''; this.style.width=''; this.style.maxWidth=''; this.style.height='';"
                            >${this.emojiDescriptions || this.emojis.join('')}</textarea>
                        </div>
                        
                        <div class="setting-group">
                            <label class="setting-label">Dailies</label>
                            <div id="goalsList"></div>
                            <div style="display: flex; align-items: center; justify-content: space-between; gap: 16px; margin-top: 12px;">
                                <button class="add-goal-btn" onclick="app.addGoal()">+ Add Daily</button>
                                <label class="checkbox-label" style="margin-bottom: 0;">
                                    <input type="checkbox" class="checkbox" ${this.showGoalsInTimeline ? 'checked' : ''} onchange="app.showGoalsInTimeline = this.checked; app.saveData()">
                                    <span>Show dailies in timeline</span>
                                </label>
                            </div>
                        </div>

                        <div class="setting-group">
                            <label class="setting-label">Start Hour</label>
                            <select class="setting-input" onchange="app.startHour = parseInt(this.value); app.saveData()">
                                ${Array.from({length: 24}, (_, i) => `
                                    <option value="${i}" ${i === this.startHour ? 'selected' : ''}>
                                        ${this.formatHour(i)}:00
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div class="setting-group">
                            <div class="export-section">
                                <button class="export-toggle" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.querySelector('.export-arrow').classList.toggle('open')">
                                    Export/Import Data
                                    <span class="export-arrow">â–¼</span>
                                </button>
                                <div class="export-content" style="display: none;">
                                    <button class="export-btn" onclick="app.exportAllToCSV()" style="margin-bottom: 12px;">
                                        Export All Data
                                    </button>
                                    <div class="import-section">
                                        <input type="file" class="import-input" accept=".csv,.json" 
                                               onchange="if(this.files.length) app.importFromCSVFile(this.files[0])">
                                    </div>
                                    <div class="export-help">
                                        Export creates two files:
                                        <br>â€¢ Monthly CSV files with daily entries
                                        <br>â€¢ JSON file with settings and goals
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        ${this.editingGoal !== null ? '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 500;" onclick="app.editingGoal = null; app.renderSettings()"></div>' : ''}
                    </div>
                `;

                this.renderGoalsList();
            }

            renderGoalsList() {
                const goalsList = document.getElementById('goalsList');
                if (!goalsList) return;
                goalsList.innerHTML = this.goals.map(goal => {
                    const isEditing = this.editingGoal === goal.id;
                    const selectedEmojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                    return `
                        <div class="goal-row">
                            <div class="goal-summary ${isEditing ? 'editing' : ''}" onclick="app.editGoal(${goal.id})">
                               <span class="goal-text-display">${this.formatGoalText(goal)}</span>
                                <button class="remove-goal-btn" onclick="event.stopPropagation(); app.removeGoal(${goal.id})">Ã—</button>
                            </div>
                            ${isEditing ? `
                                <div class="goal-editor">
                                    <div class="goal-editor-section">
                                        <div class="goal-emoji-grid">
                                            ${this.emojis.map(emoji => `
                                                <button class="goal-emoji-btn ${selectedEmojis.includes(emoji) ? 'selected' : ''}"
                                                        onclick="app.toggleGoalEmoji(${goal.id}, '${emoji}')">
                                                    ${emoji}
                                                </button>
                                            `).join('')}
                                        </div>
                                        <div class="operator-value-group">
                                            <button class="goal-action-btn goal-toggle" onclick="app.toggleGoalNegation(${goal.id})">
                                                ${goal.not ? 'is not' : 'is'}
                                            </button>
                                            <button class="goal-operator-btn goal-toggle" onclick="app.cycleOperator(${goal.id})">
                                                ${goal.operator.replace('_', ' ')}
                                            </button>
                                            <input type="number" 
                                                   class="goal-value-input" 
                                                   value="${goal.value}" 
                                                   min="0" 
                                                   max="23"
                                                   onclick="event.stopPropagation()"
                                                   onblur="app.updateGoal(${goal.id}, { value: parseInt(this.value) || 0 })">
                                            <span style="color: #e5e7eb; font-size: 1.2rem;">
                                                ${goal.operator.includes('than') ? 'times' : ''}
                                            </span>
                                        </div>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }).join('');
            }

            extractEmojis(text) {
                // Split text into proper grapheme clusters using Intl.Segmenter
                const segments = [...new Intl.Segmenter().segment(text)]
                    .map(x => x.segment)
                    .filter(segment => segment.match(/\p{Emoji}/u));
                
                // Remove duplicates
                return Array.from(new Set(segments));
            }

            handleEmojiInput(value) {
                // Store the full text input
                this.emojiDescriptions = value;
                
                // Extract and update emojis list
                const emojis = this.extractEmojis(value);
                if (emojis.length > 0) {
                    this.emojis = emojis;
                }
                
                this.saveData();
            }
            

            toggleGoalEmoji(goalId, emoji) {
                const goal = this.goals.find(g => g.id === goalId);
                let emojis = Array.isArray(goal.emojis) ? [...goal.emojis] : [goal.emoji];
                if (emojis.includes(emoji)) {
                    emojis = emojis.filter(e => e !== emoji);
                } else {
                    emojis.push(emoji);
                }
                if (emojis.length === 0) emojis = [emoji];
                this.updateGoal(goalId, { emojis });
            }
            
                toggleGoalNegation(goalId) {
                    const goal = this.goals.find(g => g.id === goalId);
                    this.updateGoal(goalId, { not: !goal.not });
                }
            

            renderDaily() {
                const goalChecks = this.checkGoals();
                
                document.getElementById('mainContainer').innerHTML = `
                    <div class="daily-container">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 16px;">
                            <button class="jump-btn" onclick="if(confirm('Clear all data for this day?')) { app.wipeCurrentDayData(); }">ðŸ—‘ï¸ wipe</button>
                            <button class="jump-btn" onclick="app.exportCurrentDayCSV()">ðŸ“‹ copy</button>
                        </div>
                        
                        <div class="bubbles-container">
                            ${(() => {
                                let bubbles = [];
                                Object.entries(this.entries).forEach(([hour, entry]) => {
                                    if (entry.emojis && entry.emojis.length > 0) {
                                        const uniqueEmojis = new Set(entry.emojis);
                                        entry.emojis.forEach((emoji, index) => {
                                            let size;
                                            if (uniqueEmojis.size === 1) {
                                                size = 70; // Large for single emoji
                                            } else if (uniqueEmojis.size === 2) {
                                                size = 50; // Medium for two emojis
                                            } else {
                                                size = 40; // Small for three or more
                                            }

                                            // Generate a unique ID for the bubble
                                            const bubbleId = `bubble-${hour}-${index}`;
                                            
                                            // Generate random position
                                            const x = Math.random() * 90 + 5; // 5-95%
                                            const y = Math.random() * 90 + 5; // 5-95%
                                            
                                            bubbles.push(`
                                                <div class="bubble" style="
                                                    left: ${x}%; 
                                                    top: ${y}%; 
                                                    width: ${size}px; 
                                                    height: ${size}px; 
                                                    font-size: ${size * 0.85}px;
                                                    transition: none;
                                                    border-radius: 50%;
                                                    display: flex;
                                                    align-items: center;
                                                    justify-content: center;
                                                    background-color: var(--color-bg-dark);
                                                ">
                                                    ${emoji}
                                                </div>
                                            `);
                                        });
                                    }
                                });
                                return bubbles.join('');
                            })()}
                        </div>
                        
                        <div class="dailies-section">
                            <h3>Dailies</h3>
                            ${goalChecks.map(goal => `
                                <div class="goal-item ${goal.met ? 'passed' : 'failed'}" style="margin-bottom:8px;">
                                    <span class="goal-text">${this.formatGoalText(goal)}</span>
                                </div>
                            `).join('')}
                            ${this.goals.length === 0 ? '<p class="no-goals-daily">No dailies set</p>' : ''}
                        </div>
                    </div>
                `;
                
                this.startBubbleAnimation();
            }
        }

        const app = new HourliesApp();
    </script>
</body>
</html>
