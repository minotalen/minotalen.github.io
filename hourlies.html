<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hourlies</title>
    <link href="https://fonts.googleapis.com/css2?family=Atkinson+Hyperlegible:wght@400;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }
        
        :root {
            --header-height: calc(48px + env(safe-area-inset-top, 16px));
            
            /* Base Colors - 6 shades */
            --color-bg-darkest: #111827;  /* Primary background */
            --color-bg-dark: #1f2937;     /* Secondary/header background */
            --color-bg-medium: #2a313e;   /* Tertiary/input background */
            --color-bg-light: #343d4e;    /* Quaternary/card background */
            --color-bg-lighter: #373e49;  /* Hover states */
            --color-bg-accent: #334970;   /* Primary buttons */
            
            /* Text Colors - 3 shades */
            --color-text-primary: #ffffff;
            --color-text-secondary: #d1d5db;
            --color-text-muted: #b4bdd0;
            
            /* Accent Colors - 3 colors */
            --color-accent-blue: #3b82f6;   /* Focus/current states */
            --color-accent-green: #364e36;  /* Success states */
            --color-accent-red: #d83939;    /* Error states */
            --color-accent-red-muted: #852727;    /* Failed dailies */
        }

        html {
            height: -webkit-fill-available;
        }

        body {
            font-family: 'Atkinson Hyperlegible', sans-serif;
            background-color: var(--color-bg-darkest);
            color: var(--color-text-primary);
            margin: 0;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        
        /* LAYOUT */
        #app {
            display: flex;
            flex-direction: column;
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }

        .header {
            background-color: var(--color-bg-dark);
            padding: env(safe-area-inset-top, 16px) 12% 12px 12%;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            min-height: var(--header-height);
            flex-shrink: 0;
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            position: relative; /* Make header relative for absolute positioning of center button */
        }
        
        /* Center the middle button on desktop */
        @media (min-width: 768px) {
            #floatingNavDate {
                position: absolute;
                left: 50%;
                transform: translateX(-50%);
                top: 50%;
                transform: translate(-50%, -50%);
            }
        }
        
        .main-container {
            flex: 1;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
            position: relative;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer and Edge */
            padding: 0;
            margin: 0;
        }
        
        .main-container::-webkit-scrollbar {
            display: none;  /* Chrome, Safari, and Opera */
        }
        
        .settings-container, .daily-container {
            padding: 16px 12%;
            min-height: 100%;
        }
        
        .scroll-container {
            padding: 16px 12%;
            margin: 0;
            min-height: 100%;
            position: relative;
            /* Hide default scrollbar */
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* Internet Explorer and Edge */
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
        }
        
        .scroll-container::-webkit-scrollbar {
            display: none;  /* Chrome, Safari, and Opera */
        }
        
        /* BUTTONS & INPUTS */
        .btn {
            background: none;
            border: none;
            color: var(--color-text-muted);
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(1.1rem, 4vw, 1.3rem);
        }
        
        .btn:hover, .btn-active {
            color: var(--color-text-primary);
        }
        
        .btn-active {
            font-weight: 700;
        }
        
        input, select, textarea {
            background: none;
            border: none;
            color: var(--color-text-muted);
            font-family: inherit;
            transition: color 0.2s;
        }
        
        input:focus, select:focus, textarea:focus {
            outline: none;
            color: var(--color-text-primary);
        }
        
        input::-webkit-outer-spin-button,
        input::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        
        input[type=number] {
            -webkit-appearance: textfield;
            appearance: textfield;
        }
        
        textarea {
            color: var(--color-text-secondary);
            font-size: 20px;
        }       
        /* HEADER */
        .header h1 {
            font-size: clamp(1.2rem, 4vw, 1.8rem);
            font-weight: 700;
            cursor: pointer;
            transition: color 0.2s;
            color: var(--color-text-muted);
            padding-top: 16px;
        }
        
        .header h1:hover {
            color: var(--color-text-primary);
        }
        
        .header-buttons {
            display: flex;
            gap: 2rem;
            align-items: center;
        }
        
        .btn-label {
            font-size: clamp(1.1rem, 2.5vw, 1.3rem);
            vertical-align: middle;
        }
        
        /* DATE NAVIGATION */
        .date-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-top: 1rem;
        }
        
        .date-nav-left, .date-nav-right {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--color-text-muted);
        }
        
        .date-input {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
            text-align: center;
            width: clamp(120px, 30vw, 140px);
            cursor: pointer;
        }
        .date-btn {
            background-color: transparent;
            color: var(--color-text-muted);
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        .secondary-btn {
            font-size: clamp(1.2rem, 5vw, 1.5rem);
        }
        
        .jump-btn {
            background-color: var(--color-bg-dark);
            color: var(--color-text-muted);
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            cursor: pointer;
            transition: color 0.2s;
            font-size: clamp(0.8rem, 3vw, 1rem);
        }
        
        .jump-btn:hover {
            color: var(--color-text-secondary);
        }
        
        .jump-btn.wipe-confirmation {
            background-color: var(--color-accent-red-muted);
            color: var(--color-text-primary);
            font-weight: bold;
            animation: pulse-warning 1s infinite alternate;
        }
        
        @keyframes pulse-warning {
            0% { transform: scale(1); opacity: 0.9; }
            100% { transform: scale(1.02); opacity: 1; }
        }
        
        /* GOALS */
        .goals-section {
            margin-bottom: 16px;
            padding: 0px;
            background-color: transparent;
            border-radius: 8px;
        }
        
        .goals-title {
            font-weight: 600;
            color: var(--color-text-secondary);
            margin-bottom: 8px;
        }
        
        .goal-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            margin-bottom: 4px;
            padding: 4px 8px;
            border-radius: 4px;
            width: fit-content;
        }
        
        .goal-item.passed {
            background-color: var(--color-accent-green);
        }
        
        .goal-item.failed {
            background-color: var(--color-accent-red-muted);
        }
        
        .goal-text {
            color: var(--color-text-secondary);
            font-size: 1.6em;
            font-weight: 500;
        }
        
        .no-goals {
            padding: 8px 12px;
            border-radius: 4px;
            background-color: var(--color-bg-medium);
            color: var(--color-text-muted);
            text-align: center;
            font-size: 14px;
        }
        
        /* HOURS */
        .hour-row {
            position: relative;
            margin-bottom: 8px;
        }
        
        .hour-entry {
            position: relative;
            cursor: pointer;
            padding: 12px 16px;
            border-radius: 4px;
            background-color: var(--color-bg-light);
            overflow: hidden;
            transition: all 0.2s;
        }
        
        .hour-entry:hover {
            background-color: var(--color-bg-lighter);
        }
        
        .hour-entry.current {
            box-shadow: 0 0 0 2px var(--color-accent-blue);
        }
        
        .hour-entry.editing {
            position: relative;
            box-shadow: 0 0 0 2px var(--color-accent-blue);
            z-index: 1000;
            user-select: text;
        }
        
        .hour-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: var(--color-bg-accent);
        }
        
        .hour-fill.empty {
            background-color: var(--color-bg-dark);
        }
        
        .hour-content {
            position: relative;
            display: flex;
            align-items: flex-start;
            gap: 6px;
        }
        
        .hour-time {
            font-size: 24px;
            width: 32px;
        }
        
        .hour-emojis {
            display: grid;
            grid-template-columns: repeat(2, 30px);
            gap: 4px;
            min-height: 30px;
            max-height: calc(30px * 3 + 8px);
            overflow: hidden;
            max-width: 64px;
            min-width: 64px;
            padding-right: 24px;
        }
        
        .hour-entry:not(.editing) .hour-content:has(.hour-text:empty) .hour-emojis {
            display: flex;
            flex-wrap: nowrap;
            gap: 4px;
            max-width: none;
            min-width: 0;
            overflow-x: auto;
        }
        
        .emoji {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            min-height: 28px;
        }
        
        .hour-input-container {
            flex: 1;
            display: flex;
            align-items: flex-start;
            position: relative;
        }
        
        .hour-input {
            flex: 1;
            background: transparent;
            color: var(--color-text-secondary);
            resize: none;
            overflow: hidden;
            min-height: 36px;
            line-height: 1.5;
            margin-top: 4px;
            transition: height 0.15s ease-out;
            user-select: text;
            white-space: pre-wrap;
        }
        
        .hour-input::placeholder {
            color: var(--color-text-muted);
        }
        
        .hour-input.empty {
            color: var(--color-text-muted);
        }
        
        .hour-input.scrolling {
            overflow-y: auto;
        }
        
        .hour-text {
            color: var(--color-text-secondary);
            font-size: 20px;
            white-space: pre-wrap;
        }
        
        .clear-btn {
            position: absolute;
            right: 0;
            top: 0;
            background: none;
            border: none;
            color: var(--color-accent-red);
            cursor: pointer;
            font-size: 36px;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
            z-index: 2;
        }
        
        /* EMOJI PICKER */
        .emoji-picker {
            position: absolute;
            left: 0;
            right: 0;
            background-color: var(--color-bg-dark);
            padding: 12px;
            display: grid;
            grid-template-columns: repeat(auto-fit, 64px);
            justify-content: center;
            gap: 8px;
            z-index: 1001;
            border-radius: 4px;
            box-shadow: 0 10px 25px var(rgba(0, 0, 0, 0.5));
        }
        
        .emoji-picker.above {
            bottom: 100%;
            margin-bottom: 8px;
        }
        
        .emoji-picker.below {
            top: 100%;
            margin-top: 8px;
        }
        
        .emoji-btn {
            padding: 8px;
            font-size: 48px;
            background: none;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            border-radius: 4px;
        }
        
        .emoji-btn:hover {
            background-color: var(--color-bg-lighter);
        }
        
        .emoji-btn.selected {
            background-color: var(--color-bg-accent);
        }
        
        .emoji-btn.selected:hover {
            background-color: var(--color-accent-blue);
        }
        
        /* SCROLL BAR */
        .scroll-bar {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 48px;
            cursor: ns-resize;
            transition: all 0.2s;
            background: repeating-linear-gradient(
                45deg,
                transparent 0px,
                transparent 3px,
                rgba(255,255,255,0.08) 3px,
                rgba(255,255,255,0.08) 4px,
                transparent 4px,
                transparent 8px
            ),
            repeating-linear-gradient(
                -45deg,
                transparent 0px,
                transparent 3px,
                rgba(255,255,255,0.08) 3px,
                rgba(255,255,255,0.08) 4px,
                transparent 4px,
                transparent 8px
            );
        }
        
        .scroll-bar.hidden {
            display: none;
        }
        
        .scroll-bar.dragging {
            background-color: var(rgba(255, 255, 255, 0.1));
        }
        
        .hour-indicator {
            position: absolute;
            right: 8px;
            width: 0;
            height: 0;
            border-left: 6px solid var(--color-accent-blue);
            border-top: 3px solid transparent;
            border-bottom: 3px solid transparent;
            animation: pulse 2s infinite;
            pointer-events: none;
            transform: translateY(-50%);
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        /* SETTINGS */
        .setting-group {
            margin-bottom: 24px;
        }
        
        .setting-label {
            display: block;
            color: var(--color-text-secondary);
            margin-bottom: 8px;
            font-size: 1.5rem;
        }
        
        .setting-input {
            width: 100%;
            padding: 12px;
            background-color: var(--color-bg-medium);
            color: var(--color-text-primary);
            border-radius: 4px;
            font-size: 18px;
            font-family: 'Atkinson Hyperlegible', monospace;
        }
        .emoji-input {
            font-size: 1.2em;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            letter-spacing: normal;
            line-height: 1.5;
            min-height: 6em;
            resize: none;
            transition: all 0.3s ease;
        }
        
        .emoji-modal .emoji-input {
            width: 100%;
            height: calc(100% - 20px);
            resize: none;
            font-size: 1.1em;
            padding: 20px;
            border: none;
            outline: none;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 18px;
            font-weight: 500;
            cursor: pointer;
            padding: 12px 16px;
            background-color: var(--color-bg-lighter);
            border-radius: 8px;
            border: 2px solid transparent;
            transition: all 0.2s;
            user-select: none;
            min-height: 48px;
        }
        
        .checkbox-label:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-text-muted);
        }
        
        .checkbox {
            width: 24px;
            height: 24px;
            cursor: pointer;
        }
        
        .add-goal-btn, .export-btn {
            background-color: var(--color-bg-accent);
            color: var(--color-text-primary);
            border: 2px solid transparent;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 18px;
            font-weight: 500;
            min-height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .add-goal-btn:hover, .export-btn:hover {
            background-color: var(--color-accent-blue);
            border-color: var(--color-accent-blue);
            transform: translateY(-1px);
        }
        
        /* GOAL EDITOR */
        .goal-row {
            position: relative;
            margin-bottom: 12px;
            display: flex;
            justify-content: center;
        }
        
        .goal-summary {
            cursor: pointer;
            padding: 12px;
            background-color: var(--color-bg-medium);
            border-radius: 6px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 12px;
            width:100%
        }
        
        .goal-summary:hover {
            background-color: var(--color-bg-lighter);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px var(rgba(0, 0, 0, 0.2));
        }
        
        .goal-summary.editing {
            background-color: var(--color-bg-dark);
            box-shadow: 0 4px 12px var(rgba(0, 0, 0, 0.3));
            transform: scale(1.02);
        }
                
        .goal-text-display {
            color: var(--color-text-secondary);
            flex: 1;
            font-size: 1.2rem;
        }
        
        /* SHARED MODAL STYLES */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal {
            position: relative;
            width: min(95%, 1000px);
            max-width: 1000px;
            max-height: 90vh;
            padding: 8px;
            background-color: var(--color-bg-dark);
            border-radius: 8px;
            border: 2px solid var(--color-bg-lighter);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.2s ease-out;
            overflow-y: auto;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }
            to { 
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        /* SHARED MODAL STYLES */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: fadeIn 0.2s ease-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .modal {
            position: relative;
            width: min(95%, 1000px);
            max-width: 1000px;
            max-height: 90vh;
            padding: 4px;
            background-color: var(--color-bg-dark);
            border-radius: 8px;
            border: 2px solid var(--color-bg-lighter);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.2s ease-out;
            overflow-y: auto;
        }
        
        @keyframes slideIn {
            from { 
                opacity: 0;
                transform: scale(0.95) translateY(-10px);
            }
            to { 
                opacity: 1;
                transform: scale(1) translateY(0);
            }
        }

        .remove-goal-btn {
            background: none;
            border: none;
            color: var(--color-text-muted);
            cursor: pointer;
            font-size: 20px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }
        
        .remove-goal-btn:hover {
            background-color: var(--color-bg-lighter);
            color: var(--color-accent-red);
        }
        
        .goal-editor-section {
            width: 100%;
        }
        
        .goal-editor {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: min(95%, 1000px);
            max-width: 1000px;
            padding: 32px;
            background-color: var(--color-bg-dark);
            border-radius: 8px;
            border: 2px solid var(--color-bg-lighter);
            z-index: 1100;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .goal-emoji-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
            gap: 8px;
            margin-bottom: 8px;
            width: 100%;
            max-height: 200px;
            overflow-y: auto;
            padding: 2px;
            border-radius: 8px;
        }

        .operator-value-group {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: nowrap;
            background: var(--color-bg-darkest);
            padding: 8px;
            border-radius: 8px;
            min-width: 100%;
        }
        
        .goal-emoji-btn {
            background: var(--color-bg-darkest);
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 8px;
            transition: all 0.2s;
        }
        
        .goal-emoji-btn:hover {
            background-color: var(--color-bg-lighter);
            transform: scale(1.05);
        }
        
        .goal-emoji-btn.selected {
            border-color: var(--color-accent-blue);
            background-color: var(--color-bg-dark);
        }
        
        .goal-toggle {
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s;
            min-height: 40px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .goal-toggle:hover {
            background-color: var(--color-bg-lighter);
            transform: translateY(-1px);
        }
        
        .goal-action-btn,
        .goal-operator-btn {
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
            padding: 10px 14px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s;
            min-height: 40px;
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .goal-action-btn:hover,
        .goal-operator-btn:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
            transform: translateY(-1px);
        }
        
        .goal-value-input {
            width: 60px;
            padding: 8px 10px;
            background-color: var(--color-bg-medium);
            border-radius: 6px;
            color: var(--color-text-secondary);
            font-size: 1rem;
            text-align: center;
            flex-shrink: 0;
            min-height: 40px;
            box-sizing: border-box;
        }
        
        .goal-times-text {
            color: var(--color-text-secondary);
            font-size: 1rem;
            font-weight: 500;
            white-space: nowrap;
            flex-shrink: 0;
        }
        
        .goal-operator-btn:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
        }
        
        .goal-value-input {
            width: 70px;
            text-align: center;
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
            border: 2px solid transparent;
            border-radius: 6px;
            padding: 10px;
            font-size: 16px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            transition: all 0.2s;
        }
        
        .goal-value-input:hover,
        .goal-value-input:focus {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
            outline: none;
        }
        
        .goal-editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 12px;
            margin-top: 24px;
        }
        
        .goal-action-btn {
            padding: 10px 20px;
            border: 2px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            background-color: var(--color-bg-medium);
            color: var(--color-text-secondary);
        }
        
        .goal-action-btn:hover {
            background-color: var(--color-bg-lighter);
            border-color: var(--color-accent-blue);
        }
        
        .goal-action-btn.secondary:hover {
            background-color: var(--color-bg-lighter);
        }
        
        /* EXPORT/IMPORT */
        .export-section {
            background-color: var(--color-bg-medium);
            border-radius: 4px;
            overflow: hidden;
        }

        .export-toggle {
            width: 100%;
            background-color: var(--color-bg-medium);
            color: var(--color-text-primary);
            border: none;
            padding: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .export-toggle:hover {
            background-color: var(--color-bg-lighter);
        }
        
        .export-arrow {
            transition: transform 0.2s;
        }
        
        .export-arrow.open {
            transform: rotate(180deg);
        }
        
        .export-content {
            padding: 12px;
            background-color: var(--color-bg-medium);
        }
        
        .import-section {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }
        
        .import-input {
            flex: 1;
            padding: 8px;
            background-color: var(--color-bg-lighter);
            color: var(--color-text-primary);
            border-radius: 4px;
            font-size: 14px;
        }
        
        .export-help {
            font-size: 12px;
            color: var(--color-text-muted);
            padding-top: 8px;
            border-top: 1px solid var(--color-bg-lighter);
        }
        
        /* DAILY VIEW */
        .bubbles-container {
            border-radius: 8px;
            height: 350px;
            position: relative;
            overflow: hidden;
            border: 1px solid var(--color-bg-medium);
            margin-bottom: 24px;
        }
        
        .bubble {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            color: var(--color-text-primary);
            background-color: var(--color-bg-dark);
        }
        
        .dailies-section h3 {
            font-size: 1.5rem;
            color: var(--color-text-secondary);
            margin-bottom: 12px;
        }
        
        .no-goals-daily {
            color: var(--color-text-muted);
            font-size: 14px;
        }
        
        /* ANIMATIONS */
        @keyframes flash-border {
            0% { box-shadow: 0 0 0 2px white; }
            100% { box-shadow: none; }
        }
        
        @keyframes copy-success {
            0% { 
                transform: scale(1); 
                background-color: var(--color-bg-dark);
                color: var(--color-text-muted);
            }
            20% { 
                transform: scale(1.05); 
                background-color: var(--color-accent-green);
                color: var(--color-text-primary);
            }
            40% { 
                transform: scale(0.98); 
            }
            60% { 
                transform: scale(1.02); 
            }
            100% { 
                transform: scale(1); 
                background-color: var(--color-accent-green);
                color: var(--color-text-primary);
            }
        }
        
        @keyframes wipe-success {
            0% { 
                transform: scale(1); 
                background-color: var(--color-accent-red-muted);
                color: var(--color-text-primary);
            }
            15% { 
                transform: scale(1.08); 
                background-color: var(--color-accent-red);
                color: var(--color-text-primary);
            }
            30% { 
                transform: scale(0.95);
                background-color: var(--color-accent-red-muted); 
            }
            45% { 
                transform: scale(1.03);
                background-color: var(--color-accent-red); 
            }
            60% { 
                transform: scale(0.99);
                background-color: var(--color-accent-red-muted); 
            }
            75% { 
                transform: scale(1.01);
                background-color: var(--color-accent-red); 
            }
            100% { 
                transform: scale(1); 
                background-color: var(--color-accent-red);
                color: var(--color-text-primary);
            }
        }
        
        .hour-entry.flash {
            animation: flash-border 0.5s ease;
        }
        
        .copy-success {
            animation: copy-success 0.6s ease-out;
        }
        
        .wipe-success {
            animation: wipe-success 0.8s ease-out;
        }
        
        /* SWIPE INDICATOR */
        .swipe-indicator {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            border-radius: 50px;
            padding: 12px 20px;
            font-size: 24px;
            z-index: 1500;
            pointer-events: none;
            transition: opacity 0.2s ease;
        }
        
        .swipe-indicator.left {
            left: 20px;
        }
        
        .swipe-indicator.right {
            right: 20px;
        }
        
            /* MOBILE */
        @media (max-width: 768px) {
            .scroll-bar { display: none !important; }
            .header { 
                padding: calc(env(safe-area-inset-top, 16px)) 16px 8px 16px;
                min-height: var(--header-height);
            }
            .settings-container, .daily-container { 
                padding: 16px;
                margin-top: 0;
            }
            
            /* Make daily view buttons stack vertically on mobile */
            .daily-container > div:first-child {
                flex-direction: column !important;
                gap: 8px !important;
            }
            
            .daily-container .jump-btn {
                width: 100% !important;
                text-align: center;
            }            .main-container:has(.daily-container) {
                overflow: hidden;
            }
            
            .daily-container {
                height: 100%;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            
            .dailies-section {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                min-height: 0;
            }
            
            .bubbles-container {
                height: 50%; /* Fixed height on mobile */
                flex-shrink: 0;
            }
            
            .scroll-container { 
                padding: 16px 0; 
                margin: 0 16px;
            }
            .header h1 { font-size: 1.4em; }
            .btn { font-size: 1.3em !important; }
            .btn-label { font-size: 0.8 em; }
            .date-nav { margin-bottom: 12px; }
            .secondary-btn, .date-input { font-size: 22px; }
            .date-input { width: 140px; }
            .hour-time { font-size: 20px; width: 28px; }
            .hour-emojis { grid-template-columns: repeat(2, 26px); gap: 2px; max-width: 54px; min-width: 54px; }
            .emoji { font-size: 24px; min-height: 24px; }
            .hour-text, .hour-input { font-size: 16px; }
            .emoji-picker { grid-template-columns: repeat(auto-fit, 42px); gap: 4px; padding: 8px; }
            .emoji-btn { width: 48px; height: 48px; font-size: 28px; }
            .setting-label, .setting-input, .checkbox-label { font-size: 16px; }
            .setting-input { padding: 10px; }
            .checkbox { width: 18px; height: 18px; }
            .dailies-section h3 { font-size: 16px; }
            .goal-text-display { font-size: 16px; }
            .goal-text { font-size: 1.3em;  }
            .add-goal-btn, .export-btn { 
                white-space: nowrap; 
                padding: 8px 16px;
                font-size: 16px;
                min-height: 40px;
            }
            .goal-summary { padding: 8px; gap: 8px; }
            .hour-entry { padding: 8px 12px; }
            .setting-group { margin-bottom: 16px; }
            .checkbox-label { padding: 8px 12px; }
            
            /* Modal adjustments for mobile */
            .modal {
                width: 95% !important;
                max-width: 95% !important;
                padding: 6px !important;
            }
            
            .operator-value-group {
                flex-wrap: wrap;
                gap: 10px;
                padding: 6px;
            }
            
            .goal-action-btn,
            .goal-operator-btn,
            .goal-toggle {
                min-width: 80px;
                font-size: 0.9rem;
                min-height: 36px;
                padding: 8px 12px;
            }
            
            .goal-value-input {
                width: 50px;
                min-height: 36px;
                font-size: 0.9rem;
            }
            
            .goal-times-text {
                font-size: 0.9rem;
            }
        }
        
        @media (max-width: 375px) {
            .header { 
                padding: env(safe-area-inset-top, 12px) 12px 6px 12px;
                min-height: calc(48px + env(safe-area-inset-top, 12px));
            }
            .header h1 { font-size: 1.2em; }
            .btn { font-size: 1.2em !important; }
            .btn-label { font-size: 0.55em; }
            .settings-container, .daily-container { padding: 8px 12px; }
            
            /* Apply same daily view fixes for smaller screens */
            .main-container:has(.daily-container) {
                overflow: hidden;
            }
            
            .daily-container {
                height: 100%;
                overflow: hidden;
                display: flex;
                flex-direction: column;
            }
            
            .dailies-section {
                flex: 1;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
                min-height: 0;
            }
            
            .bubbles-container {
                height: 200px; /* Smaller height for very small screens */
                flex-shrink: 0;
            }
            
            .scroll-container { padding: 8px 0; margin: 0 12px; }
            .hour-time { font-size: 18px; width: 24px; }
            .hour-emojis { grid-template-columns: repeat(2, 24px); max-width: 50px; min-width: 50px; }
            .emoji { font-size: 22px; min-height: 22px; }
            .hour-text, .hour-input { font-size: 16px; }
            .emoji-picker { grid-template-columns: repeat(4, 1fr); gap: 4px; padding: 6px; }
            .emoji-btn { padding: 4px; font-size: 24px; }
            .date-input, .secondary-btn { font-size: 18px; }
            .add-goal-btn, .export-btn { 
                white-space: nowrap; 
                padding: 6px 12px;
                font-size: 14px;
                min-height: 36px;
            }
            .goal-summary { padding: 6px; gap: 6px; }
            .hour-entry { padding: 6px 10px; }
            .setting-group { margin-bottom: 12px; }
            .checkbox-label { padding: 6px 10px; }
            
            /* Modal adjustments for small mobile */
            .modal {
                width: 98% !important;
                max-width: 98% !important;
                padding: 4px !important;
            }
            
            .operator-value-group {
                flex-wrap: wrap;
                gap: 6px;
                padding: 4px;
            }
            
            .goal-action-btn,
            .goal-operator-btn,
            .goal-toggle {
                min-width: 70px;
                font-size: 0.8rem;
                padding: 8px 10px;
                min-height: 32px;
            }
            
            .goal-value-input {
                width: 45px;
                min-height: 32px;
                font-size: 0.8rem;
                padding: 6px 8px;
            }
            
            .goal-times-text {
                font-size: 0.8rem;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div class="header">
            <div style="display: flex; align-items: center; gap: 16px;">
                <h1><div class="btn-active" id="floatingNavDate">hourlies</div></h1>
                <button class="btn" onclick="app.undo()" id="undoBtn" style="display: none;">⎌</button>
            </div>
            <div class="header-buttons">
                <button class="btn" onclick="app.setView('daily')" title="Press 'D'">🎯 <span class="btn-label">daily</span></button>
                <button class="btn" onclick="app.setView('settings')" title="Press 'E'">⚙ <span class="btn-label">edit</span></button>
            </div>
        </div>
        <div class="main-container" id="mainContainer"></div>
    </div>

    <script>
        class HourliesApp {

            constructor() {
                this.currentTime = new Date();
                this.startHour = 7;
                this.allEntries = {};
                this.goals = [];
                this.emojis = [
                    // Core categories
                    '🔵', '🟡', '🟢', '🟣',
                    // Everyday basics  
                    '🍔', '☕', '�', '👣',
                    // Social & emotional
                    '💬', '♥️', '🥵',
                    // Extras
                    '�', '🎮', '👩‍💻', '🎨',
                    // Additional commonly used
                    '🌿', '🔴', '🟩', '📷', '💊', '🍕'
                ];
                this.emojiDescriptions = ''; // Store the full emoji input text
                this.showGoalsInTimeline = false;
                this.emojiMergeMode = 'none'; // 'none', 'touch', 'all'
                this.bubbleSizeModifier = 1.0; // Global size scaling factor
                this.overlapFrameCount = 0; // Track consecutive frames with overlaps
                
                this.currentDate = new Date();
                this.editingHour = null;
                this.editingGoal = null;
                this.view = 'timeline';
                this.undoStack = [];
                this.clipboardEntry = null;
                this.wipeConfirmationStep = 0; // Track multi-step wipe confirmation (0-3)
                this.timelineScrollPosition = 0;
                this.hoveredHour = null; // Track which hour entry is currently being hovered
                this.editStartState = null; // Store entries state when editing starts

                this.loadData();
                this.currentDate = this.getEffectiveDate();
                this.render();
                this.startTimer();
                this.setupEvents();
                setTimeout(() => this.scrollToCurrentHour(), 100);
            }

            // === DATA ===
            loadData() {
                const saved = localStorage.getItem("hourliesData");
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        Object.assign(this, {
                            allEntries: data.allEntries || {},
                            goals: data.goals || [],
                            emojis: data.emojis || this.emojis,
                            emojiDescriptions: data.emojiDescriptions || '',
                            startHour: data.startHour ?? this.startHour,
                            showGoalsInTimeline: data.showGoalsInTimeline ?? false,
                            emojiMergeMode: data.emojiMergeMode || 'none'
                        });
                    } catch (e) {
                        console.warn("Failed to load saved data", e);
                    }
                } else {
                    this.createWelcomeMessage();
                }
            }

            createWelcomeMessage() {
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

                const allWelcomeEntries = {
                    7: { emojis: ['👋'], text: 'welcome to hourlies!' },
                    8: { emojis: ['📊'], text: 'see where your time really goes with minimal effort and zero guilt' },
                    
                    10: { emojis: ['✏️'], text: 'log what happened each hour, because honest data reveals real patterns' },
                    11: { emojis: ['⚙️'], text: 'customize your emoji categories and set personal rules in Edit' },
                    12: { emojis: ['🎯'], text: 'your rules, your metrics. track what matters to you, not what others expect' },
                    
                    14: { emojis: ['🔍'], text: 'goals compare your intentions against reality and show you the gaps' },
                    15: { emojis: ['🏠'], text: 'daily view gives you a visual overview of your whole day' },
                    16: { emojis: ['🗑️'], text: 'wipe button clears current day if you want to start fresh' },
                    
                    18: { emojis: ['🔄'], text: 'patterns over perfection. work with your reality instead of fighting it' },
                    19: { emojis: ['🌙'], text: 'track honestly to enable self-discovery, improvement starts with awareness' },

                    21: { emojis: ['🔒'], text: 'everything is completely private and stays on your device' },
                    
                    23: { emojis: ['📄'], text: isMobile ? 'long-tap an hour to copy' : 'right-click an hour to copy its entry' },
                    0: { emojis: ['📄'], text: 'paste copied entries into empty hours' },
                    1: { emojis: ['⌨️'], text: isMobile ? '' : 'use arrow keys for quickly navigating between hours and days' },
                    2: { emojis: ['📄'], text: 'if you make a mistake, you can undo it with the ⎌ button in the header bar' },
                    };

                // Use effective date logic to determine proper calendar days for welcome messages
                const effectiveDate = this.getEffectiveDate();
                const currentDayKey = this.dateKey(effectiveDate);
                const nextDay = new Date(effectiveDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                
                // Ensure the days exist
                if (!this.allEntries[currentDayKey]) this.allEntries[currentDayKey] = {};
                if (!this.allEntries[nextDayKey]) this.allEntries[nextDayKey] = {};
                
                // Store entries in appropriate days with one loop
                Object.entries(allWelcomeEntries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });

                // Set default emoji categories on first launch
                if (!this.emojiDescriptions) {
                    this.emojiDescriptions = `Use these categories as base for your own personalized set.

🔵 Chores / errands — cleaning, shopping, cooking, transit  
🟡 Rest / fun — TV, games, downtime  
🟢 Work / projects — job tasks, creative work  
🟣 Learning / study — courses, reading, practice

Everyday basics
🍔 Food
☕ Caffeine / stimulants
😴 Sleep / nap
🚶 Movement / sports

Social & emotional
💬 Social
♥️ Romance
🥵 Stress

Extras
📖 Reading  
👾 Gaming
👩‍💻 Coding / tech
▶️ Youtube`;
                    
                    // Extract emojis from the descriptions and update the emoji array
                    const extractedEmojis = this.extractEmojis(this.emojiDescriptions);
                    if (extractedEmojis.length > 0) {
                        this.emojis = extractedEmojis;
                    }
                }

                // Add default rules if none exist
                if (!this.goals || this.goals.length === 0) {
                    this.goals = [
                        { id: Date.now() + 1, emojis: ['🚶'], operator: 'more_than', value: 0 }, // movement daily
                        { id: Date.now() + 2, emojis: ['💬'], operator: 'more_than', value: 0 }, // social connection daily  
                        { id: Date.now() + 3, emojis: ['😴'], operator: 'before', value: 1 }, // sleep before 1am
                        { id: Date.now() + 4, emojis: ['☕'], operator: 'more_than', value: 3, not: true }, // limit coffee
                    ];
                }
            }

            saveData() {
                localStorage.setItem("hourliesData", JSON.stringify({
                    allEntries: this.allEntries,
                    goals: this.goals,
                    emojis: this.emojis,
                    emojiDescriptions: this.emojiDescriptions,
                    startHour: this.startHour,
                    showGoalsInTimeline: this.showGoalsInTimeline,
                    emojiMergeMode: this.emojiMergeMode
                }));
            }

            updateEntries(newEntries) {
                this.undoStack.push({ 
                    entries: { ...this.entries }, 
                    timestamp: Date.now(),
                    date: new Date(this.currentDate) // Store the date for undo
                });
                if (this.undoStack.length > 100) this.undoStack.shift();
                
                this.updateEntriesWithoutUndo(newEntries);
            }

            updateEntriesWithoutUndo(newEntries) {
                const { currentDayKey, nextDayKey } = this.ensureCalendarDaysExist();
                
                // Store entries in correct calendar days
                Object.entries(newEntries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        // Hours 7-23 go to current calendar day
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        // Hours 0-6 go to next calendar day
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });
                
                this.updateUndoButton();
                this.saveData();
            }

            // === UTILITIES ===
            dateKey(date) { return date ? date.toISOString().split('T')[0] : ''; }
            
            get currentDateKey() { 
                // For data storage, we need to account for hours that belong to previous day
                const effectiveDate = new Date(this.currentDate);
                return this.dateKey(effectiveDate);
            }
            
            get entries() { 
                const { currentDayEntries, nextDayEntries } = this.getCalendarDayEntries();
                const combinedEntries = {};
                
                // Add hours 7-23 from current calendar day
                for (let hour = this.startHour; hour < 24; hour++) {
                    if (currentDayEntries[hour]) {
                        combinedEntries[hour] = currentDayEntries[hour];
                    }
                }
                
                // Add hours 0-(startHour-1) from next calendar day
                for (let hour = 0; hour < this.startHour; hour++) {
                    if (nextDayEntries[hour]) {
                        combinedEntries[hour] = nextDayEntries[hour];
                    }
                }
                
                return combinedEntries;
            }

            getTotalEmojiCount() {
                return Object.values(this.entries).reduce((total, entry) => {
                    return total + (entry.emojis ? entry.emojis.length : 0);
                }, 0);
            }

            cycleMergeMode() {
                const modes = ['none', 'touch', 'all'];
                const currentIndex = modes.indexOf(this.emojiMergeMode);
                const nextIndex = (currentIndex + 1) % modes.length;
                const oldMode = this.emojiMergeMode;
                this.emojiMergeMode = modes[nextIndex];
                this.saveData();
                
                // Update button text without full redraw
                const mergeButton = document.querySelector('button[onclick*="cycleMergeMode"]');
                if (mergeButton) {
                    mergeButton.textContent = this.getMergeModeLabel();
                }
                
                // Handle mode-specific transitions
                if (this.emojiMergeMode === 'all' && oldMode !== 'all') {
                    // Switching to 'all' mode - needs immediate merge
                    this.render();
                } else if (this.emojiMergeMode === 'none' && oldMode === 'all') {
                    // Switching from 'all' to 'none' - split merged bubbles without redraw
                    this.splitMergedBubbles();
                }
            }

            splitMergedBubbles() {
                const container = document.querySelector('.bubbles-container');
                if (!container) return;
                
                const bubbles = container.querySelectorAll('.bubble');
                const newBubbles = [];
                
                bubbles.forEach(bubble => {
                    const count = parseInt(bubble.dataset.count || '1');
                    if (count > 1) {
                        // This is a merged bubble - split it
                        const emoji = bubble.dataset.emoji;
                        const currentSize = parseFloat(bubble.style.width);
                        const currentX = parseFloat(bubble.style.left);
                        const currentY = parseFloat(bubble.style.top);
                        
                        // Calculate individual bubble size (reverse of merge calculation)
                        const totalArea = Math.PI * Math.pow(currentSize / 2, 2);
                        const individualArea = totalArea / count;
                        const individualSize = Math.sqrt(individualArea / Math.PI) * 2;
                        
                        // Remove the merged bubble
                        bubble.remove();
                        
                        // Create individual bubbles
                        for (let i = 0; i < count; i++) {
                            // Position them in a small cluster around the original position
                            const angle = (i / count) * Math.PI * 2;
                            const radius = currentSize * 0.3; // Small spread
                            const offsetX = Math.cos(angle) * radius * (i > 0 ? 1 : 0); // First bubble stays in center
                            const offsetY = Math.sin(angle) * radius * (i > 0 ? 1 : 0);
                            
                            const newBubble = document.createElement('div');
                            newBubble.className = 'bubble';
                            newBubble.dataset.emoji = emoji;
                            newBubble.dataset.count = '1';
                            newBubble.style.left = `${Math.max(0, Math.min(currentX + offsetX / container.offsetWidth * 100, 100 - individualSize / container.offsetWidth * 100))}%`;
                            newBubble.style.top = `${Math.max(0, Math.min(currentY + offsetY / container.offsetHeight * 100, 100 - individualSize / container.offsetHeight * 100))}%`;
                            newBubble.style.width = `${individualSize}px`;
                            newBubble.style.height = `${individualSize}px`;
                            newBubble.style.fontSize = `${individualSize * 0.85}px`;
                            newBubble.style.position = 'absolute';
                            newBubble.style.borderRadius = '50%';
                            newBubble.style.display = 'flex';
                            newBubble.style.alignItems = 'center';
                            newBubble.style.justifyContent = 'center';
                            newBubble.style.backgroundColor = 'var(--color-bg-dark)';
                            newBubble.style.lineHeight = '1';
                            newBubble.style.transition = 'none';
                            newBubble.innerHTML = emoji;
                            
                            container.appendChild(newBubble);
                            newBubbles.push(newBubble);
                        }
                    }
                });
                
                // Restart animation with new bubbles if there were any splits
                if (newBubbles.length > 0) {
                    setTimeout(() => this.startBubbleAnimation(), 50);
                }
            }

            getMergeModeLabel() {
                // COMMENTED OUT: Auto-merge lock logic
                // const isLocked = this.isAutoMergeActive();
                // const lockIcon = isLocked ? '🔒 ' : '';
                const lockIcon = ''; // No lock icon for testing
                
                switch (this.emojiMergeMode) {
                    case 'none': return `${lockIcon}⚫ no merge`;
                    case 'touch': return `${lockIcon}🤝 merge on touch`;
                    case 'all': return `${lockIcon}🟡 merge all`;
                    default: return `${lockIcon}⚫ no merge`;
                }
            }

            processBubblesForMerging() {
                const bubbles = [];
                
                // Collect all emojis with their hour and index
                Object.entries(this.entries).forEach(([hour, entry]) => {
                    if (entry.emojis && entry.emojis.length > 0) {
                        entry.emojis.forEach((emoji, index) => {
                            bubbles.push({
                                emoji,
                                hour: parseInt(hour),
                                originalIndex: index,
                                id: `${hour}-${index}`
                            });
                        });
                    }
                });

                if (this.emojiMergeMode === 'all') {
                    // Group by emoji type and calculate merged bubble sizes
                    const emojiGroups = {};
                    bubbles.forEach(bubble => {
                        if (!emojiGroups[bubble.emoji]) {
                            emojiGroups[bubble.emoji] = [];
                        }
                        emojiGroups[bubble.emoji].push(bubble);
                    });

                    const mergedBubbles = [];
                    Object.entries(emojiGroups).forEach(([emoji, group]) => {
                        // Calculate total area: area of each bubble is π * (size/2)²
                        // For individual bubbles, we need to determine their size first
                        let totalArea = 0;
                        const uniqueEmojisInHour = new Set();
                        
                        // Calculate area based on original sizing rules
                        group.forEach(bubble => {
                            const hourEmojis = this.entries[bubble.hour].emojis || [];
                            const uniqueCount = new Set(hourEmojis).size;
                            let individualSize;
                            if (uniqueCount === 1) {
                                individualSize = 70;
                            } else if (uniqueCount === 2) {
                                individualSize = 50;
                            } else {
                                individualSize = 40;
                            }
                            // Area = π * r² = π * (size/2)²
                            const area = Math.PI * Math.pow(individualSize / 2, 2);
                            totalArea += area;
                        });

                        // Calculate new radius from total area: r = sqrt(totalArea / π)
                        const newRadius = Math.sqrt(totalArea / Math.PI);
                        const newSize = newRadius * 2;

                        mergedBubbles.push({
                            emoji,
                            count: group.length,
                            size: Math.min(Math.max(newSize, 30), 150), // Clamp size between 30-150px
                            id: `merged-${emoji}`,
                            x: Math.random() * 90 + 5,
                            y: Math.random() * 90 + 5
                        });
                    });

                    // Calculate total bubble area and apply scaling for fill percentage
                    const totalBubbleArea = mergedBubbles.reduce((total, bubble) => {
                        const radius = bubble.size / 2;
                        return total + (Math.PI * radius * radius);
                    }, 0);
                    
                    // Mobile-specific fill percentage vs desktop
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    let estimatedContainerArea, targetFillPercent;
                    
                    if (isMobile) {
                        // Mobile container is 50% of viewport height, typically around 300-400px wide
                        const mobileHeight = window.innerHeight * 0.5;
                        const mobileWidth = Math.min(window.innerWidth * 0.76, 400); // Account for 12% side padding
                        estimatedContainerArea = mobileHeight * mobileWidth;
                        targetFillPercent = 35; // Reduced from 55% to fit properly on mobile
                    } else {
                        // Desktop: 350px x 350px container
                        estimatedContainerArea = 350 * 350;
                    }
                    
                    const currentFillPercent = (totalBubbleArea / estimatedContainerArea) * 100;
                    
                    let scaleFactor = 1;
                    if (isMobile) {
                        // Target specific fill percentage on mobile
                        if (mergedBubbles.length > 0) {
                            scaleFactor = Math.sqrt(targetFillPercent / currentFillPercent);
                        }
                    } else {
                        // Desktop: keep fill between 30% and 60%
                        if (currentFillPercent > 60) {
                            scaleFactor = Math.sqrt(60 / currentFillPercent);
                        } else if (currentFillPercent < 30 && mergedBubbles.length > 0) {
                            scaleFactor = Math.sqrt(30 / currentFillPercent);
                        }
                    }
                    
                    // Apply scaling to all bubbles
                    const scaledMergedBubbles = mergedBubbles.map(bubble => ({
                        ...bubble,
                        size: Math.max(bubble.size * scaleFactor, 20) // Minimum size of 20px
                    }));

                    return scaledMergedBubbles;
                } else {
                    // For 'none' and 'touch' modes, return individual bubbles with original sizing
                    const individualBubbles = bubbles.map(bubble => {
                        const hourEmojis = this.entries[bubble.hour].emojis || [];
                        const uniqueCount = new Set(hourEmojis).size;
                        let size;
                        if (uniqueCount === 1) {
                            size = 70;
                        } else if (uniqueCount === 2) {
                            size = 50;
                        } else {
                            size = 40;
                        }

                        return {
                            ...bubble,
                            size,
                            count: 1,
                            x: Math.random() * 90 + 5,
                            y: Math.random() * 90 + 5
                        };
                    });

                    // Calculate total bubble area and apply scaling for fill percentage
                    const totalBubbleArea = individualBubbles.reduce((total, bubble) => {
                        const radius = bubble.size / 2;
                        return total + (Math.PI * radius * radius);
                    }, 0);
                    
                    // Mobile-specific fill percentage vs desktop
                    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
                    let estimatedContainerArea, targetFillPercent;
                    
                    if (isMobile) {
                        // Mobile container is 50% of viewport height, typically around 300-400px wide
                        const mobileHeight = window.innerHeight * 0.5;
                        const mobileWidth = Math.min(window.innerWidth * 0.76, 400); // Account for 12% side padding
                        estimatedContainerArea = mobileHeight * mobileWidth;
                        targetFillPercent = 35; // Reduced from 55% to fit properly on mobile
                    } else {
                        // Desktop: 350px x 350px container
                        estimatedContainerArea = 350 * 350;
                    }
                    
                    const currentFillPercent = (totalBubbleArea / estimatedContainerArea) * 100;
                    
                    let scaleFactor = 1;
                    if (isMobile) {
                        // Target specific fill percentage on mobile
                        if (individualBubbles.length > 0) {
                            scaleFactor = Math.sqrt(targetFillPercent / currentFillPercent);
                        }
                    } else {
                        // Desktop: keep fill between 30% and 60%
                        if (currentFillPercent > 60) {
                            scaleFactor = Math.sqrt(60 / currentFillPercent);
                        } else if (currentFillPercent < 30 && individualBubbles.length > 0) {
                            scaleFactor = Math.sqrt(30 / currentFillPercent);
                        }
                    }
                    
                    // Apply scaling to all bubbles
                    return individualBubbles.map(bubble => ({
                        ...bubble,
                        size: Math.max(bubble.size * scaleFactor, 20) // Minimum size of 20px
                    }));
                }
            }
            
            get hours() { return Array.from({length: 24}, (_, i) => (this.startHour + i) % 24); }
            formatHour(hour) { return hour.toString().padStart(2, '0'); }
            
            // Helper methods for calendar day operations
            getCalendarDayKeys() {
                const currentDayKey = this.dateKey(this.currentDate);
                const nextDay = new Date(this.currentDate);
                nextDay.setDate(nextDay.getDate() + 1);
                const nextDayKey = this.dateKey(nextDay);
                return { currentDayKey, nextDayKey };
            }

            ensureCalendarDaysExist() {
                const { currentDayKey, nextDayKey } = this.getCalendarDayKeys();
                if (!this.allEntries[currentDayKey]) this.allEntries[currentDayKey] = {};
                if (!this.allEntries[nextDayKey]) this.allEntries[nextDayKey] = {};
                return { currentDayKey, nextDayKey };
            }

            getCalendarDayEntries() {
                const { currentDayKey, nextDayKey } = this.getCalendarDayKeys();
                return {
                    currentDayEntries: this.allEntries[currentDayKey] || {},
                    nextDayEntries: this.allEntries[nextDayKey] || {}
                };
            }

            clearCurrentDayEntries() {
                const { currentDayKey, nextDayKey } = this.getCalendarDayKeys();
                // Clear current entries
                if (this.allEntries[currentDayKey]) {
                    for (let hour = this.startHour; hour < 24; hour++) {
                        delete this.allEntries[currentDayKey][hour];
                    }
                }
                if (this.allEntries[nextDayKey]) {
                    for (let hour = 0; hour < this.startHour; hour++) {
                        delete this.allEntries[nextDayKey][hour];
                    }
                }
            }

            // Helper method for focusing textarea and setting cursor to end
            focusTextareaAtEnd(hour, delay = 0) {
                const focusAndSetCursor = () => {
                    const textarea = document.querySelector(`[data-hour="${hour}"] textarea`);
                    if (textarea) {
                        textarea.focus();
                        textarea.selectionStart = textarea.selectionEnd = textarea.value.length;
                    }
                };
                
                if (delay > 0) {
                    setTimeout(focusAndSetCursor, delay);
                } else {
                    focusAndSetCursor();
                }
            }

            formatDateInput() {
                if (!this.currentDate) return '';
                return [
                    this.currentDate.getDate().toString().padStart(2, '0'),
                    (this.currentDate.getMonth() + 1).toString().padStart(2, '0'),
                    this.currentDate.getFullYear().toString().slice(-2)
                ].join('/');
            }

            getEffectiveDate() {
                // Get the current logical day based on start hour
                const d = new Date(this.currentTime);
                if (d.getHours() < this.startHour) {
                    d.setDate(d.getDate() - 1);
                }
                return d;
            }

            compareDateToToday() {
                const todayKey = this.dateKey(this.getEffectiveDate());
                const currentKey = this.currentDateKey;
                if (currentKey === todayKey) return 0;  // current
                return currentKey < todayKey ? -1 : 1;   // past : future
            }

            isCurrentDate() { return this.compareDateToToday() === 0; }
            isPastDate() { return this.compareDateToToday() < 0; }
            isFutureDate() { return this.compareDateToToday() > 0; }

            getHourFill(hour) {
                // Skip fill logic if not on current day
                if (!this.isCurrentDate()) {
                    if (this.isPastDate()) return 100;
                    return 0;
                }

                const currentHour = this.currentTime.getHours();
                const adjustedHour = hour < this.startHour ? hour + 24 : hour;
                const adjustedCurrentHour = currentHour < this.startHour ? currentHour + 24 : currentHour;
                
                if (adjustedHour < adjustedCurrentHour) return 100;
                if (adjustedHour === adjustedCurrentHour) return (this.currentTime.getMinutes() / 60) * 100;
                return 0;
            }

            isCurrentHour(hour) {
                return this.isCurrentDate() && this.currentTime.getHours() === hour;
            }

            // === EVENTS ===
            setupEvents() {
                // Initialize swipe state with responsive thresholds
                this.swipeState = {
                    startX: 0,
                    startY: 0,
                    startTime: 0,
                    isDragging: false,
                    minSwipeDistance: Math.min(80, window.innerWidth * 0.2), // 20% of screen width, max 80px
                    maxVerticalDistance: 150, // Allow more vertical movement for scrolling
                    maxSwipeTime: 600, // Slightly longer time allowance for swipes
                    minHorizontalThreshold: 15 // Minimum horizontal movement to start tracking
                };

                // Global keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts when typing in input fields
                    if (e.target.matches('input, textarea')) return;
                    
                    // Don't trigger when editing an hour
                    if (this.editingHour !== null) return;
                    
                    switch (e.key.toLowerCase()) {
                        case 'arrowleft':
                            this.navigateDay(-1);
                            e.preventDefault();
                            break;
                        case 'arrowright':
                            this.navigateDay(1);
                            e.preventDefault();
                            break;
                        case 'f':
                            document.querySelector('.date-input')?.focus();
                            e.preventDefault();
                            break;
                        case 'e':
                            this.setView('settings');
                            e.preventDefault();
                            break;
                        case 'd':
                            this.setView('daily');
                            e.preventDefault();
                            break;
                        case 'h':
                            this.setView('timeline');
                            e.preventDefault();
                            break;
                    }
                });
                
                // Handle backspace/delete on hover
                document.addEventListener('keydown', (e) => {
                    if ((e.key === 'Backspace' || e.key === 'Delete') && 
                        this.editingHour === null && // Not in edit mode
                        this.hoveredHour !== null && // Hovering over an entry
                        this.view === 'timeline' && // In timeline view
                        !e.target.matches('input, textarea')) { // Not typing in an input
                        this.clearEntry(this.hoveredHour);
                        e.preventDefault(); // Prevent browser back navigation
                    }
                });

                document.addEventListener('click', (e) => {
                    if (this.editingHour === null) return;
                    const isInterface = e.target.classList.contains('app-overlay') ||
                                      e.target.classList.contains('hour-input') ||
                                      e.target.classList.contains('clear-btn') ||
                                      e.target.classList.contains('emoji-btn');
                    if (!isInterface) {
                        e.preventDefault();
                        this.focusTextareaAtEnd(this.editingHour, 0);
                    }
                });
            }

            // === SWIPE DETECTION ===
            setupSwipeEvents(container) {
                if (!container) return;

                let swipeIndicator = null;

                const showSwipeIndicator = (direction) => {
                    // Remove existing indicator
                    if (swipeIndicator) {
                        swipeIndicator.remove();
                    }
                    
                    // Create new indicator
                    swipeIndicator = document.createElement('div');
                    swipeIndicator.className = `swipe-indicator ${direction}`;
                    swipeIndicator.innerHTML = direction === 'left' ? '→' : '←';
                    document.body.appendChild(swipeIndicator);
                    
                    // Auto-remove after animation
                    setTimeout(() => {
                        if (swipeIndicator) {
                            swipeIndicator.remove();
                            swipeIndicator = null;
                        }
                    }, 300);
                };

                const handleTouchStart = (e) => {
                    // Don't interfere with editing or form inputs
                    if (this.editingHour !== null || e.target.matches('input, textarea, button')) {
                        return;
                    }

                    // Disable day swiping if touch is within the bubbles container
                    const bubblesContainer = document.querySelector('.bubbles-container');
                    if (bubblesContainer && bubblesContainer.contains(e.target)) {
                        return; // Exit early to prevent swipe handling
                    }

                    const touch = e.touches[0];
                    this.swipeState.startX = touch.clientX;
                    this.swipeState.startY = touch.clientY;
                    this.swipeState.startTime = Date.now();
                    this.swipeState.isDragging = false;
                };

                const handleTouchMove = (e) => {
                    if (this.editingHour !== null || !e.touches[0]) return;

                    // Don't process swipe moves if touch started in bubbles container
                    const bubblesContainer = document.querySelector('.bubbles-container');
                    if (bubblesContainer && bubblesContainer.contains(e.target)) {
                        return;
                    }

                    const touch = e.touches[0];
                    const deltaX = Math.abs(touch.clientX - this.swipeState.startX);
                    const deltaY = Math.abs(touch.clientY - this.swipeState.startY);

                    // Start tracking as potential swipe if horizontal movement exceeds threshold
                    if (!this.swipeState.isDragging && deltaX > this.swipeState.minHorizontalThreshold) {
                        // Only start dragging if horizontal movement is significantly greater than vertical
                        if (deltaX > deltaY * 1.5) {
                            this.swipeState.isDragging = true;
                        }
                    }

                    // Prevent vertical scrolling if we're in a horizontal swipe
                    if (this.swipeState.isDragging) {
                        e.preventDefault();
                    }
                };

                const handleTouchEnd = (e) => {
                    if (this.editingHour !== null) {
                        this.swipeState.isDragging = false;
                        return;
                    }

                    // Don't process swipe end if touch is within bubbles container
                    const bubblesContainer = document.querySelector('.bubbles-container');
                    if (bubblesContainer && bubblesContainer.contains(e.target)) {
                        this.swipeState.isDragging = false;
                        return;
                    }

                    const touch = e.changedTouches[0];
                    const deltaX = touch.clientX - this.swipeState.startX;
                    const deltaY = Math.abs(touch.clientY - this.swipeState.startY);
                    const deltaTime = Date.now() - this.swipeState.startTime;

                    // Check if this qualifies as a horizontal swipe
                    const isHorizontalSwipe = 
                        Math.abs(deltaX) >= this.swipeState.minSwipeDistance &&
                        deltaY <= this.swipeState.maxVerticalDistance &&
                        deltaTime <= this.swipeState.maxSwipeTime &&
                        this.swipeState.isDragging;

                    if (isHorizontalSwipe) {
                        // Determine direction: negative deltaX = swipe left (next day), positive = swipe right (previous day)
                        const direction = deltaX < 0 ? 1 : -1;
                        const swipeDirection = deltaX < 0 ? 'left' : 'right';
                        
                        // Show visual feedback
                        showSwipeIndicator(swipeDirection);
                        
                        // Navigate after brief delay for visual feedback
                        setTimeout(() => this.navigateDay(direction), 100);
                    }

                    this.swipeState.isDragging = false;
                };

                // Add touch event listeners
                container.addEventListener('touchstart', handleTouchStart, { passive: true });
                container.addEventListener('touchmove', handleTouchMove, { passive: false });
                container.addEventListener('touchend', handleTouchEnd, { passive: true });
            }

            // === NAVIGATION ===
            navigateDay(direction) {
                this.finishEditing();
                this.currentDate.setDate(this.currentDate.getDate() + direction);
                this.updateHeaderTitle();
                this.render();
            }

            jumpToToday() {
                this.finishEditing();
                this.currentDate = this.getEffectiveDate();
                this.render();
                setTimeout(() => this.scrollToCurrentHour(), 100);
            }

            setView(view) {
                if (this.view === 'timeline' && view !== 'timeline') {
                    const container = document.querySelector('.daily-container');
                    if (container) this.timelineScrollPosition = container.scrollTop;
                }

                this.finishEditing();
                this.view = view;
                this.editingGoal = null;
                this.updateHeaderTitle();
                this.render();
            }

            updateHeaderTitle() {
                const floatingNavDate = document.getElementById('floatingNavDate');
                if (!floatingNavDate) return;

                if (this.view === 'timeline') {
                    // Always show date if not today, otherwise show "hourlies"
                    if (!this.isCurrentDate()) {
                        floatingNavDate.textContent = this.formatNavbarDate(this.currentDate).toLowerCase();
                        floatingNavDate.onclick = () => app.jumpToToday();
                    } else {
                        floatingNavDate.textContent = "hourlies";
                        floatingNavDate.onclick = () => app.setView('timeline');
                    }
                    floatingNavDate.classList.add('btn-active');
                } else {
                    floatingNavDate.textContent = "← " + this.formatNavbarDate(this.currentDate).toLowerCase();
                    floatingNavDate.classList.remove('btn-active');

                        floatingNavDate.onclick = () => app.setView('timeline');
                }
            }

            handleScroll(e) {
                const scrolled = e.target.scrollTop > 150;
                const floatingNavDate = document.getElementById('floatingNavDate');
                
                if (floatingNavDate) {
                    if (this.view === 'timeline') {
                        if (!this.isCurrentDate()) {
                            // Always show date if not today, regardless of scroll
                            floatingNavDate.textContent = this.formatNavbarDate(this.currentDate).toLowerCase();
                            floatingNavDate.onclick = () => app.jumpToToday();
                        } else if (scrolled) {
                            // Show date when scrolled and on today
                            floatingNavDate.textContent = this.formatNavbarDate(this.currentDate).toLowerCase();
                            floatingNavDate.onclick = () => {
                                document.getElementById('mainContainer').scrollTo({ top: 0, behavior: 'smooth' });
                            };
                        } else {
                            // Show "hourlies" when not scrolled and on today
                            floatingNavDate.textContent = "hourlies";
                            floatingNavDate.onclick = () => app.setView('timeline');
                        }
                        floatingNavDate.classList.add('btn-active');
                    } else {
                        floatingNavDate.textContent = "← " + this.formatNavbarDate(this.currentDate).toLowerCase();
                        floatingNavDate.classList.remove('btn-active');
                        floatingNavDate.onclick = () => app.setView('timeline');
                    }
                }
            }

            // === DATE INPUT ===
            handleDateInput(event) {
                const value = event.target.value.replace(/\D/g, '');
                event.target.value = value.match(/.{1,2}/g)?.join('/') || value;

                const parseAndSetDate = (value, useCurrentYear = false) => {
                    const day = parseInt(value.slice(0, 2), 10);
                    const month = parseInt(value.slice(2, 4), 10) - 1;
                    const year = useCurrentYear ? this.currentTime.getFullYear() : 2000 + parseInt(value.slice(4, 6), 10);

                    // Set currentDate and currentTime to the user's entered date
                    const inputDate = new Date(year, month, day, 12, 0, 0);

                    if (!isNaN(inputDate.getTime()) && day > 0 && day <= 31 && month >= 0 && month < 12) {
                        this.currentDate = new Date(year, month, day);
                        // Don't modify currentTime - it should always be the actual current time
                        event.target.value = this.formatDateInput();
                        this.render();
                        return true;
                    }
                    return false;
                };

                if (value.length === 4 && (event.type === 'blur' || event.key === 'Enter')) {
                    if (!parseAndSetDate(value, true)) {
                        event.target.value = this.formatDateInput();
                    }
                } else if (value.length === 6) {
                    parseAndSetDate(value);
                }
            }

            formatNavbarDate(date) {
                return date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }).toLowerCase();
            }

            handleDateKeydown(event) {
                const allowed = ['Backspace', 'Delete', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Escape'];
                if (!/^\d$/.test(event.key) && !allowed.includes(event.key)) {
                    event.preventDefault();
                }
                if (event.key === 'Enter') {
                    event.preventDefault();
                    event.target.blur();
                } else if (event.key === 'Escape') {
                    event.preventDefault();
                    event.target.value = this.formatDateInput();
                    event.target.blur();
                }
            }

            handleDateFocus(event) {
                event.target.select();
                event.target.addEventListener('blur', (e) => this.handleDateInput(e), { once: true });
            }

            // === HOURS ===
            editHour(hour) {
                if (this.editingHour === hour) return;
                
                // Finish any current editing session
                this.finishEditing();
                
                // Save state when starting to edit (before any changes)
                this.editStartState = { ...this.entries };
                this.editingHour = hour;
                this.renderHours();
                
                setTimeout(() => {
                    const hourElement = document.querySelector(`[data-hour="${hour}"]`);
                    const textarea = hourElement?.querySelector('textarea');
                    if (textarea) {
                        if (window.innerWidth <= 768) {
                            const container = document.querySelector('.scroll-container');
                            const containerRect = container.getBoundingClientRect();
                            const elementRect = hourElement.getBoundingClientRect();
                            const relativeTop = elementRect.top - containerRect.top;
                            const targetPosition = containerRect.height * 0.15;
                            container.scrollTop = container.scrollTop + (relativeTop - targetPosition);
                        } else {
                            hourElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                        
                        this.focusTextareaAtEnd(hour, 20);
                    }
                }, 30);
            }

            updateText(text) {
                const entry = this.entries[this.editingHour] || { emojis: [], text: '' };
                const newEntries = { ...this.entries };
                newEntries[this.editingHour] = { ...entry, text };
                
                // Update entries without adding to undo stack (we'll do that on edit completion)
                this.updateEntriesWithoutUndo(newEntries);
            }

            finishEditing() {
                if (this.editingHour === null) return;
                
                // Add undo entry for the entire edit session
                if (this.editStartState) {
                    // Check if anything actually changed
                    const currentEntries = { ...this.entries };
                    const hasChanges = JSON.stringify(this.editStartState) !== JSON.stringify(currentEntries);
                    
                    if (hasChanges) {
                        this.undoStack.push({ 
                            entries: { ...this.editStartState }, 
                            timestamp: Date.now(),
                            date: new Date(this.currentDate)
                        });
                        if (this.undoStack.length > 100) this.undoStack.shift();
                    }
                    
                    this.editStartState = null;
                }
                
                this.editingHour = null;
                this.renderHours();
            }

            clearEntry(hour) {
                // If we're clearing the currently edited hour, finish editing first
                if (this.editingHour === hour) {
                    this.finishEditing();
                }
                
                const newEntries = { ...this.entries };
                newEntries[hour] = { emojis: [], text: '' };
                this.updateEntries(newEntries);
                this.renderHours();
            }

            toggleEmoji(emoji) {
                const entry = this.entries[this.editingHour] || { emojis: [], text: '' };
                const validEmojis = entry.emojis.filter(e => this.emojis.includes(e));
                const newEmojis = validEmojis.includes(emoji)
                    ? validEmojis.filter(e => e !== emoji)
                    : [...validEmojis, emoji];
                const newEntries = { ...this.entries };
                newEntries[this.editingHour] = { ...entry, emojis: newEmojis };
                
                // Update entries without adding to undo stack (we'll do that on edit completion)
                this.updateEntriesWithoutUndo(newEntries);
                this.renderHours();
                this.renderGoals();
                this.focusTextareaAtEnd(this.editingHour, 20);
            }

            handleHourInputKeydown(event, hour) {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    this.finishEditing();
                } else if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    const textarea = event.target;
                    const cursorAtEnd = textarea.selectionStart === textarea.value.length;
                    
                    // Only navigate if cursor is at the very end of the text
                    if (cursorAtEnd) {
                        event.preventDefault();
                        const currentIndex = this.hours.indexOf(hour);
                        const nextIndex = event.key === 'ArrowUp' 
                            ? (currentIndex - 1 + this.hours.length) % this.hours.length
                            : (currentIndex + 1) % this.hours.length;
                        const nextHour = this.hours[nextIndex];

                        // Finish current edit before moving to next
                        this.finishEditing();
                        
                        // Start editing the next hour
                        this.editStartState = { ...this.entries };
                        this.editingHour = nextHour;
                        this.renderHours();
                        
                        this.focusTextareaAtEnd(nextHour, 0);
                    }
                }
            }

            // === COPY/PASTE ===
            handleCopyPaste(hour, entry, element) {
                const hasContent = (entry.text && entry.text.trim()) || (entry.emojis && entry.emojis.length > 0);

                if (hasContent) {
                    this.clipboardEntry = {
                        emojis: entry.emojis ? [...entry.emojis] : [],
                        text: entry.text || ""
                    };
                    element.classList.add("flash");
                    setTimeout(() => element.classList.remove("flash"), 500);
                } else if (this.clipboardEntry) {
                    const newEntries = { ...this.entries };
                    newEntries[hour] = { ...this.clipboardEntry };
                    this.updateEntries(newEntries);
                    this.renderHours();
                }
            }

            attachCopyPasteEvents() {
                document.querySelectorAll(".hour-entry").forEach(el => {
                    const hour = parseInt(el.dataset.hour);
                    const entry = this.entries[hour] || { emojis: [], text: "" };

                    el.addEventListener("mouseenter", () => {
                        this.hoveredHour = hour;
                    });

                    el.addEventListener("mouseleave", () => {
                        this.hoveredHour = null;
                    });

                    el.addEventListener("contextmenu", (e) => {
                        e.preventDefault();
                        this.handleCopyPaste(hour, entry, el);
                    });

                    let longPressTimer;
                    el.addEventListener("touchstart", () => {
                        longPressTimer = setTimeout(() => {
                            this.handleCopyPaste(hour, entry, el);
                            el._suppressClick = true;
                        }, 500);
                    });
                    
                    el.addEventListener("touchend", () => clearTimeout(longPressTimer));
                    el.addEventListener("touchmove", () => clearTimeout(longPressTimer));

                    el.addEventListener("click", (e) => {
                        if (el._suppressClick) {
                            e.stopImmediatePropagation();
                            el._suppressClick = false;
                        }
                    }, true);
                });
            }

            // === GOALS ===
            addGoal() {
                const newGoal = {
                    id: Date.now(),
                    emojis: [this.emojis[0] || '📖'],
                    operator: 'more_than',
                    value: 1
                };
                this.goals.push(newGoal);
                this.renderSettings();
            }

            updateGoal(id, updates) {
                this.goals = this.goals.map(goal => goal.id === id ? { ...goal, ...updates } : goal);
                this.saveData();
                
                // If we're editing this goal in a modal, update the modal content instead of full re-render
                if (this.editingGoal === id) {
                    this.updateGoalModal();
                } else {
                    this.renderSettings();
                }
            }

            removeGoal(id) {
                this.goals = this.goals.filter(goal => goal.id !== id);
                this.saveData();
                this.renderSettings();
            }
            
            updateGoalModal() {
                // Update only the modal content without re-rendering the entire settings view
                const modalContent = document.querySelector('.modal .goal-editor-section');
                if (modalContent && this.editingGoal !== null) {
                    const goal = this.goals.find(g => g.id === this.editingGoal);
                    if (goal) {
                        const selectedEmojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                        
                        // Update emoji selection
                        const emojiButtons = modalContent.querySelectorAll('.goal-emoji-btn');
                        emojiButtons.forEach(btn => {
                            const emoji = btn.textContent.trim();
                            if (selectedEmojis.includes(emoji)) {
                                btn.classList.add('selected');
                            } else {
                                btn.classList.remove('selected');
                            }
                        });
                        
                        // Update toggle buttons
                        const negationBtn = modalContent.querySelector('.goal-action-btn');
                        if (negationBtn) negationBtn.textContent = goal.not ? 'is not' : 'is';
                        
                        const operatorBtn = modalContent.querySelector('.goal-operator-btn');
                        if (operatorBtn) operatorBtn.textContent = goal.operator.replace('_', ' ');
                        
                        const valueInput = modalContent.querySelector('.goal-value-input');
                        if (valueInput) valueInput.value = goal.value;
                        
                        const timesText = modalContent.querySelector('.goal-times-text');
                        if (timesText) timesText.textContent = goal.operator.includes('than') ? 'times' : '';
                    }
                }
                
                // Also update the goal list to reflect changes
                this.renderGoalsList();
            }

            editGoal(id) {
                const wasEditing = this.editingGoal === id;
                this.editingGoal = this.editingGoal === id ? null : id;
                this.renderSettings();
            }

            cycleOperator(goalId) {
                const goal = this.goals.find(g => g.id === goalId);
                const operators = ['more_than', 'less_than', 'before', 'after'];
                const currentIndex = operators.indexOf(goal.operator);
                const nextIndex = (currentIndex + 1) % operators.length;
                this.updateGoal(goalId, { operator: operators[nextIndex] });
            }

            formatGoalText(goal) {
                const opText = goal.operator.replace('_', ' ');
                const suffix = goal.operator.includes('than') ? ' times' : '';
                const negation = goal.not ? 'not ' : '';
                const emojiText = Array.isArray(goal.emojis) ? goal.emojis.join(' ') : goal.emoji;
                return `${negation}${emojiText} ${opText} ${goal.value}${suffix}`;
            }

            checkGoals() {
                const dayEntries = Object.values(this.entries);
                return this.goals.map(goal => {
                    const emojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                    // Count total appearances of any emoji in the rule
                    const emojiCount = dayEntries.reduce((count, entry) => {
                        return count + emojis.reduce((c, emoji) => c + (entry.emojis?.filter(e => e === emoji).length || 0), 0);
                    }, 0);
                    // Find all hours where any emoji in the rule appears
                    const emojiHours = Object.keys(this.entries).filter(hour => {
                        const entryEmojis = this.entries[hour].emojis || [];
                        return emojis.some(emoji => entryEmojis.includes(emoji));
                    }).map(Number);
                    let met = false;
                    if (goal.operator === 'more_than') {
                        met = emojiCount > goal.value;
                    } else if (goal.operator === 'less_than') {
                        met = emojiCount < goal.value;
                    } else if (goal.operator === 'before' && emojiHours.length > 0) {
                        const adjustedHours = emojiHours.map(h => h < this.startHour ? h + 24 : h);
                        const adjustedTarget = goal.value < this.startHour ? goal.value + 24 : goal.value;
                        met = Math.min(...adjustedHours) < adjustedTarget;
                    } else if (goal.operator === 'after' && emojiHours.length > 0) {
                        const adjustedHours = emojiHours.map(h => h < this.startHour ? h + 24 : h);
                        const adjustedTarget = goal.value < this.startHour ? goal.value + 24 : goal.value;
                        met = Math.max(...adjustedHours) > adjustedTarget;
                    }
                    if (goal.not) met = !met;
                    return { ...goal, met, emojiCount };
                });
            }

            // === TIMER ===
            startTimer() {
                setInterval(() => {
                    this.currentTime = new Date();
                    
                    // Only update the UI if we're on the current day and in timeline view
                    if (this.isCurrentDate() && this.view === 'timeline' && this.editingHour === null) {
                        this.renderHours();
                    }
                }, 60000);
            }

            undo() {
                if (this.undoStack.length === 0) return;
                const lastState = this.undoStack.pop();
                
                // Restore the date from the undo state
                if (lastState.date) {
                    this.currentDate = new Date(lastState.date);
                }
                
                // Clear current entries and restore from undo state
                this.clearCurrentDayEntries();
                const { currentDayKey, nextDayKey } = this.ensureCalendarDaysExist();
                
                // Restore entries using same logic as updateEntriesWithoutUndo
                Object.entries(lastState.entries).forEach(([hour, entry]) => {
                    const hourNum = parseInt(hour);
                    if (hourNum >= this.startHour) {
                        this.allEntries[currentDayKey][hourNum] = entry;
                    } else {
                        this.allEntries[nextDayKey][hourNum] = entry;
                    }
                });
                
                this.updateUndoButton();
                this.renderHours();
                this.saveData();
            }

            updateUndoButton() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.style.display = this.view === 'timeline' && this.undoStack.length > 0 ? 'block' : 'none';
                }
            }

            scrollToCurrentHour() {
                const container = document.querySelector('.scroll-container');
                if (!container) return;
                const currentHourIndex = this.hours.findIndex(hour => hour === this.currentTime.getHours());
                if (currentHourIndex === -1) return;
                const hourElements = container.querySelectorAll('[data-hour]');
                const targetElement = hourElements[currentHourIndex];
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }

            // === EXPORT ===
            exportCurrentDayText() {
                let content = "";
                
                // Export entries in order starting from day start time (this.startHour)
                this.hours.forEach(hour => {
                    const entry = this.entries[hour] || { emojis: [], text: '' };
                    const emojis = entry.emojis?.join('') || '';
                    const text = entry.text || '';
                    
                    // Format: [hour]: emojis text
                    const hourFormatted = this.formatHour(hour);
                    const entryContent = `${emojis}${text ? ' ' + text : ''}`.trim();
                    
                    if (entryContent) {
                        content += `${hourFormatted}: ${entryContent}\n`;
                    } else {
                        content += `${hourFormatted}\n`;
                    }
                });
                
                try {
                    navigator.clipboard.writeText(content);
                } catch (err) {
                    // Fallback: create a text file download
                    const blob = new Blob([content], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `hourlies-${this.formatDateInput()}.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            }

            exportCurrentDayTextWithAnimation() {
                const copyBtn = document.getElementById('copyDayBtn');
                const isToday = this.isCurrentDate();
                const originalLabel = isToday ? '📋 copy today' : '📋 share your day';
                
                // First, execute the copy functionality
                this.exportCurrentDayText();
                
                // Then animate and update button
                copyBtn.classList.add('copy-success');
                copyBtn.innerHTML = '✅ copied to clipboard';
                
                // Reset after 5 seconds
                setTimeout(() => {
                    copyBtn.classList.remove('copy-success');
                    copyBtn.innerHTML = originalLabel;
                }, 5000);
            }

            groupEntriesByMonth() {
                const months = {};
                Object.entries(this.allEntries).forEach(([dateKey, entries]) => {
                    const [year, month] = dateKey.split('-');
                    const monthKey = `${year}-${month}`;
                    if (!months[monthKey]) months[monthKey] = {};
                    months[monthKey][dateKey] = entries;
                });
                return months;
            }

            exportAllToJSON() {
                const exportData = {
                    timestamp: new Date().toISOString(),
                    settings: {
                        emojis: this.emojis,
                        emojiDescriptions: this.emojiDescriptions,
                        startHour: this.startHour,
                        showGoalsInTimeline: this.showGoalsInTimeline,
                        emojiMergeMode: this.emojiMergeMode
                    },
                    goals: this.goals.map(goal => ({
                        ...goal,
                        emojis: Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji]
                    })),
                    entries: this.allEntries
                };

                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                const timestamp = new Date().toISOString().split('T')[0];
                a.href = url;
                a.download = `hourlies-export-${timestamp}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            importFromJSONFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        console.log('Importing data:', importData);
                        
                        // Complete export format
                        if (importData.settings) {
                            if (Array.isArray(importData.settings.emojis)) {
                                this.emojis = [...importData.settings.emojis];
                            }
                            if (importData.settings.emojiDescriptions) {
                                this.emojiDescriptions = importData.settings.emojiDescriptions;
                            }
                            if (typeof importData.settings.startHour === 'number' && 
                                importData.settings.startHour >= 0 && 
                                importData.settings.startHour < 24) {
                                this.startHour = importData.settings.startHour;
                            }
                            if (typeof importData.settings.showGoalsInTimeline === 'boolean') {
                                this.showGoalsInTimeline = Boolean(importData.settings.showGoalsInTimeline);
                            }
                            if (importData.settings.emojiMergeMode && 
                                ['none', 'touch', 'all'].includes(importData.settings.emojiMergeMode)) {
                                this.emojiMergeMode = importData.settings.emojiMergeMode;
                            }
                        }
                        if (Array.isArray(importData.goals)) {
                            const validOperators = ['more_than', 'less_than', 'before', 'after'];
                            this.goals = importData.goals.filter(goal => {
                                return goal && 
                                        goal.id && 
                                        Array.isArray(goal.emojis) && 
                                        validOperators.includes(goal.operator) && 
                                        typeof goal.value === 'number';
                            }).map(goal => ({
                                ...goal,
                                not: Boolean(goal.not),
                                value: Math.max(0, Math.min(23, goal.value))
                            }));
                        }
                        if (importData.entries && typeof importData.entries === 'object') {
                            // Import all entries
                            this.allEntries = { ...this.allEntries, ...importData.entries };
                        }
                                                
                        this.saveData();
                        this.render();
                        alert('Data imported successfully');
                    } catch (err) {
                        console.error('Import error:', err);
                        alert('Error importing data: ' + (err.message || 'Invalid JSON file'));
                    }
                };

                reader.readAsText(file);
            }

            wipeCurrentDayData() {
                // Save current entries to undo stack before wiping
                this.undoStack.push({ 
                    entries: { ...this.entries }, 
                    timestamp: Date.now(),
                    date: new Date(this.currentDate)
                });
                if (this.undoStack.length > 100) this.undoStack.shift();
                
                // Clear the day and update UI
                this.clearCurrentDayEntries();
                this.wipeConfirmationStep = 0; // Reset confirmation state
                this.updateUndoButton();
                this.render();
                this.saveData();
            }

            wipeCurrentDayDataWithAnimation() {
                const wipeBtn = document.getElementById('wipeDayBtn');
                const isToday = this.isCurrentDate();
                const originalLabel = isToday ? '🗑️ wipe today' : '🗑️ wipe current day';
                
                // First, execute the wipe functionality (this will clear entries and re-render)
                this.wipeCurrentDayData();
                
                // Get the button reference again after re-render and animate it
                setTimeout(() => {
                    const newWipeBtn = document.getElementById('wipeDayBtn');
                    if (newWipeBtn) {
                        // Remove any existing confirmation classes and add success animation
                        newWipeBtn.classList.remove('wipe-confirmation');
                        newWipeBtn.classList.add('wipe-success');
                        newWipeBtn.innerHTML = '✅ day cleared';
                        
                        // Reset after 3 seconds
                        setTimeout(() => {
                            if (newWipeBtn) {
                                newWipeBtn.classList.remove('wipe-success');
                                newWipeBtn.innerHTML = originalLabel;
                            }
                        }, 3000);
                    }
                }, 50);
            }

            handleWipeConfirmation() {
                if (this.wipeConfirmationStep >= 1) {
                    // Second step - actually wipe the data with animation
                    this.wipeCurrentDayDataWithAnimation();
                } else {
                    // First step - advance to confirmation
                    this.wipeConfirmationStep++;
                    this.updateWipeButton();
                }
            }

            resetWipeConfirmation() {
                if (this.wipeConfirmationStep > 0) {
                    this.wipeConfirmationStep = 0;
                    this.updateWipeButton();
                }
            }

            updateWipeButton() {
                const wipeBtn = document.getElementById('wipeDayBtn');
                if (!wipeBtn) return;

                const isToday = this.isCurrentDate();
                const wipeLabel = isToday ? 'wipe today' : 'wipe current day';
                
                // Get wipe button text based on confirmation step
                let wipeButtonText;
                if (this.wipeConfirmationStep === 0) {
                    wipeButtonText = `🗑️ ${wipeLabel}`;
                } else if (this.wipeConfirmationStep === 1) {
                    const dayText = isToday ? 'today' : 'day';
                    wipeButtonText = `⚠️ delete all entries of ${dayText}`;
                } else {
                    wipeButtonText = '🚨 are you sure?';
                }

                // Update button text and styling
                wipeBtn.innerHTML = wipeButtonText;
                
                // Update CSS classes
                if (this.wipeConfirmationStep > 0) {
                    wipeBtn.classList.add('wipe-confirmation');
                } else {
                    wipeBtn.classList.remove('wipe-confirmation');
                }
            }

            startBubbleAnimation() {
                // Clean up any existing animation
                if (this.bubbleAnimationId) {
                    cancelAnimationFrame(this.bubbleAnimationId);
                    this.bubbleAnimationId = null;
                }

                // Clean up any existing drag event listeners
                if (this.dragCleanupFunctions) {
                    this.dragCleanupFunctions.forEach(cleanup => cleanup());
                    this.dragCleanupFunctions = [];
                }

                const container = document.querySelector('.bubbles-container');
                if (!container) return;
                const bubbles = container.querySelectorAll('.bubble');
                const containerRect = container.getBoundingClientRect();
                const bubbleStates = new Map();
                
                // Drag state
                let draggedBubble = null;
                let dragStartX = 0;
                let dragStartY = 0;
                let dragStartTime = 0;
                let lastDragX = 0;
                let lastDragY = 0;
                let dragVelocityX = 0;
                let dragVelocityY = 0;
                const maxThrowSpeed = 15;
                let billiardsMode = false; // (gravity disabled)
                
                // Physics constants
                const centerGravity = 0.02;
                const friction = 0.995;
                const gravityRestitution = 0.2; 
                const billiardsRestitution = 0.85;
                const repulsion = 0.2; // Increased from 0.2 to prevent overlaps
                const maxSpeed = 10;
                const minSpeed = 0;
                const gravityDampening = 0.7;

                // Initialize bubbles randomly across the entire container
                // Initialize bubbles with no overlaps
                bubbles.forEach((bubble) => {
                    const size = parseFloat(bubble.style.width);
                    const containerWidth = containerRect.width;
                    const containerHeight = containerRect.height;
                    const padding = size;
                    
                    let attempts = 0;
                    let pixelX, pixelY;
                    let overlap;
                    
                    // Try to find non-overlapping position
                    do {
                        pixelX = padding + Math.random() * (containerWidth - size - padding * 2);
                        pixelY = padding + Math.random() * (containerHeight - size - padding * 2);
                        
                        overlap = false;
                        // Check against all existing bubbles
                        bubbleStates.forEach((existingState) => {
                            const dx = (pixelX + size/2) - (existingState.x + existingState.size/2);
                            const dy = (pixelY + size/2) - (existingState.y + existingState.size/2);
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            if (distance < (size + existingState.size) / 2) {
                                overlap = true;
                            }
                        });
                        attempts++;
                    } while (overlap && attempts < 100); // Prevent infinite loop
                    
                    // Initial velocity with random direction
                    const angle = Math.random() * Math.PI * 2;
                    const speed = Math.random() * 0.5 + 0.5; // 0.5-1.0 base speed
                    const initialVelX = Math.cos(angle) * speed;
                    const initialVelY = Math.sin(angle) * speed;
                
                bubbleStates.set(bubble, {
                    x: pixelX,
                    y: pixelY,
                    vx: initialVelX === 0 ? 0.1 : initialVelX, // Ensure non-zero initial velocity
                    vy: initialVelY === 0 ? 0.1 : initialVelY,
                    size: size,
                });
                });

                // Add drag event handlers
                const handleDragStart = (e, bubble) => {
                    e.preventDefault();
                    draggedBubble = bubble;
                    const rect = container.getBoundingClientRect();
                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    dragStartX = lastDragX = clientX - rect.left;
                    dragStartY = lastDragY = clientY - rect.top;
                    dragStartTime = performance.now();
                    dragVelocityX = dragVelocityY = 0;
                    bubble.style.cursor = 'grabbing';
                    bubble.style.zIndex = '1000';
                    
                    // Store drag path for better velocity calculation
                    this.dragPath = [{ x: dragStartX, y: dragStartY, time: dragStartTime }];
                    
                    // Immediately position bubble under cursor
                    const state = bubbleStates.get(draggedBubble);
                    if (state) {
                        state.x = Math.max(0, Math.min(dragStartX - state.size / 2, containerRect.width - state.size));
                        state.y = Math.max(0, Math.min(dragStartY - state.size / 2, containerRect.height - state.size));
                        state.vx = 0;
                        state.vy = 0;
                        
                        // Immediately update visual position
                        const newX = (state.x / containerRect.width) * 100;
                        const newY = (state.y / containerRect.height) * 100;
                        draggedBubble.style.left = `${newX}%`;
                        draggedBubble.style.top = `${newY}%`;
                    }
                };

                const handleDragMove = (e) => {
                    if (!draggedBubble) return;
                    e.preventDefault();
                    
                    const rect = container.getBoundingClientRect();
                    const clientX = e.type.includes('touch') ? e.touches[0].clientX : e.clientX;
                    const clientY = e.type.includes('touch') ? e.touches[0].clientY : e.clientY;
                    const currentX = clientX - rect.left;
                    const currentY = clientY - rect.top;
                    const currentTime = performance.now();
                    
                    // Store drag path point
                    this.dragPath = this.dragPath || [];
                    this.dragPath.push({ x: currentX, y: currentY, time: currentTime });
                    
                    // Keep only recent path points (last 100ms for smooth velocity calculation)
                    const cutoffTime = currentTime - 100;
                    this.dragPath = this.dragPath.filter(point => point.time >= cutoffTime);
                    
                    // Calculate velocity from recent path
                    if (this.dragPath.length >= 2) {
                        const recent = this.dragPath[this.dragPath.length - 1];
                        const previous = this.dragPath[Math.max(0, this.dragPath.length - 3)]; // Use point from 2-3 frames ago
                        const timeDelta = recent.time - previous.time;
                        
                        if (timeDelta > 0) {
                            dragVelocityX = (recent.x - previous.x) / timeDelta * 16; // Scale to ~60fps
                            dragVelocityY = (recent.y - previous.y) / timeDelta * 16;
                        }
                    }
                    
                    // Update bubble position immediately for fluid dragging
                    const state = bubbleStates.get(draggedBubble);
                    if (state) {
                        state.x = Math.max(0, Math.min(currentX - state.size / 2, containerRect.width - state.size));
                        state.y = Math.max(0, Math.min(currentY - state.size / 2, containerRect.height - state.size));
                        state.vx = 0; // Stop physics velocity while dragging
                        state.vy = 0;
                        
                        // Immediately update visual position for fluid feel
                        const newX = (state.x / containerRect.width) * 100;
                        const newY = (state.y / containerRect.height) * 100;
                        draggedBubble.style.left = `${newX}%`;
                        draggedBubble.style.top = `${newY}%`;
                    }
                    
                    lastDragX = currentX;
                    lastDragY = currentY;
                };

                const handleDragEnd = (e) => {
                    if (!draggedBubble) return;
                    
                    const state = bubbleStates.get(draggedBubble);
                    if (state) {
                        // Apply throw velocity with max speed limit as force
                        const throwSpeed = Math.sqrt(dragVelocityX * dragVelocityX + dragVelocityY * dragVelocityY);
                        if (throwSpeed > maxThrowSpeed) {
                            const scale = maxThrowSpeed / throwSpeed;
                            dragVelocityX *= scale;
                            dragVelocityY *= scale;
                        }
                        
                        // Apply velocity as force (additive to current velocity for billiards effect)
                        state.vx += dragVelocityX;
                        state.vy += dragVelocityY;
                        
                        // Cap the final velocity to max speed
                        const finalSpeed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                        if (finalSpeed > maxSpeed) {
                            const scale = maxSpeed / finalSpeed;
                            state.vx *= scale;
                            state.vy *= scale;
                        }
                    }
                    
                    // Enable billiards mode - gravity/repulsion stay disabled
                    billiardsMode = true;
                    
                    draggedBubble.style.cursor = 'grab';
                    draggedBubble.style.zIndex = '';
                    draggedBubble = null;
                    this.dragPath = []; // Clear drag path
                };

                // Add event listeners to bubbles
                this.dragCleanupFunctions = [];
                bubbles.forEach(bubble => {
                    bubble.style.cursor = 'grab';
                    const mouseDownHandler = (e) => handleDragStart(e, bubble);
                    const touchStartHandler = (e) => handleDragStart(e, bubble);
                    
                    bubble.addEventListener('mousedown', mouseDownHandler);
                    bubble.addEventListener('touchstart', touchStartHandler, { passive: false });
                    
                    // Store cleanup functions
                    this.dragCleanupFunctions.push(() => {
                        bubble.removeEventListener('mousedown', mouseDownHandler);
                        bubble.removeEventListener('touchstart', touchStartHandler);
                        bubble.style.cursor = '';
                    });
                });

                // Add global event listeners for drag move and end
                document.addEventListener('mousemove', handleDragMove);
                document.addEventListener('mouseup', handleDragEnd);
                document.addEventListener('touchmove', handleDragMove, { passive: false });
                document.addEventListener('touchend', handleDragEnd);

                // Store global cleanup functions
                this.dragCleanupFunctions.push(() => {
                    document.removeEventListener('mousemove', handleDragMove);
                    document.removeEventListener('mouseup', handleDragEnd);
                    document.removeEventListener('touchmove', handleDragMove);
                    document.removeEventListener('touchend', handleDragEnd);
                });

                // Add focus/blur listeners to exit billiards mode
                const handleFocus = () => {
                    billiardsMode = false; // Re-enable gravity/repulsion
                };
                
                const handleBlur = () => {
                    billiardsMode = false; // Re-enable gravity/repulsion
                };

                // Add click/tap outside container to exit billiards mode
                const handleOutsideClick = (e) => {
                    // Check if click is outside the bubbles container
                    if (!container.contains(e.target) && billiardsMode) {
                        billiardsMode = false; // Re-enable gravity/repulsion
                    }
                };

                const handleOutsideTouch = (e) => {
                    // Check if touch is outside the bubbles container
                    if (e.touches.length > 0) {
                        const touch = e.touches[0];
                        const elementUnderTouch = document.elementFromPoint(touch.clientX, touch.clientY);
                        if (!container.contains(elementUnderTouch) && billiardsMode) {
                            billiardsMode = false; // Re-enable gravity/repulsion
                        }
                    }
                };

                window.addEventListener('focus', handleFocus);
                window.addEventListener('blur', handleBlur);
                document.addEventListener('click', handleOutsideClick);
                document.addEventListener('touchstart', handleOutsideTouch);
                
                // Clean up all event listeners
                this.dragCleanupFunctions.push(() => {
                    window.removeEventListener('focus', handleFocus);
                    window.removeEventListener('blur', handleBlur);
                    document.removeEventListener('click', handleOutsideClick);
                    document.removeEventListener('touchstart', handleOutsideTouch);
                });

                let lastFrame = performance.now();
                const animate = (currentTime) => {
                    if (!document.querySelector('.bubbles-container')) {
                        // Clean up drag event listeners when animation stops
                        if (this.dragCleanupFunctions) {
                            this.dragCleanupFunctions.forEach(cleanup => cleanup());
                            this.dragCleanupFunctions = [];
                        }
                        
                        cancelAnimationFrame(this.bubbleAnimationId);
                        this.bubbleAnimationId = null;
                        return; // Stop if container is gone
                    }

                    const deltaTime = Math.min(currentTime - lastFrame, 32); // Cap at ~30fps
                    lastFrame = currentTime;

                    // Apply forces and update positions
                    bubbleStates.forEach((state, bubble) => {
                        // Skip physics for dragged bubble
                        if (bubble === draggedBubble) {
                            return; // Position is already being handled by drag events
                        }
                        
                        // Skip gravity/repulsion for ALL bubbles when any bubble is being dragged OR in billiards mode
                        if (!draggedBubble && !billiardsMode) {
                            // Use mouse position as gravity center when hovering
                            const bubbleCenterX = state.x + state.size / 2;
                            const bubbleCenterY = state.y + state.size / 2;
                            const containerRadius = Math.min(containerRect.width, containerRect.height) / 2;
                            
                            // Default to container center if mouse is not over container
                            const containerCenterX = this.mouseX || containerRect.width / 2;
                            const containerCenterY = this.mouseY || containerRect.height / 2;

                            // Calculate gravity/repulsion with improved stability
                            const dx = containerCenterX - bubbleCenterX;
                            const dy = containerCenterY - bubbleCenterY;
                            const distToCenter = Math.sqrt(dx * dx + dy * dy);
                            if (distToCenter > 0) {
                                // Calculate normalized direction
                                const dirX = dx / distToCenter;
                                const dirY = dy / distToCenter;
                                
                                // Calculate force strength with smooth falloff
                                const normalizedDist = Math.min(distToCenter / containerRadius, 1);
                                let forceStrength;
                                
                                // Repel if mouse is over container, attract otherwise
                                if (this.mouseX != null && this.mouseY != null) {
                                    // Stronger repulsion when closer to mouse
                                    forceStrength = -centerGravity * 15 * (1 - Math.pow(normalizedDist, 0.8));
                                } else {
                                    // Normal center attraction when no mouse
                                    forceStrength = centerGravity * 0.7 * Math.pow(normalizedDist, 1.2);
                                }
                                
                                // Apply force with dampening based on current velocity
                                const currentSpeed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                                const dampening = Math.max(0, 1 - (currentSpeed / maxSpeed) * gravityDampening);
                                
                                state.vx += dirX * forceStrength * dampening;
                                state.vy += dirY * forceStrength * dampening;
                            }
                        } // End of gravity/repulsion when not dragging

                        // Apply friction
                        state.vx *= friction;
                        state.vy *= friction;

                        // Maintain minimum and maximum speed
                        const speed = Math.sqrt(state.vx * state.vx + state.vy * state.vy);
                        if (speed < minSpeed) {
                            const scale = minSpeed / speed;
                            state.vx *= scale;
                            state.vy *= scale;
                        } else if (speed > maxSpeed) {
                            const scale = maxSpeed / speed;
                            state.vx *= scale;
                            state.vy *= scale;
                        }

                        // Update position
                        state.x += state.vx;
                        state.y += state.vy;

                        // Bounce off container bounds (rectangular boundary)
                        const radius = state.size / 2;
                        const currentRestitution = billiardsMode ? billiardsRestitution : gravityRestitution;
                        
                        // Right wall
                        if (state.x + state.size > containerRect.width) {
                            state.x = containerRect.width - state.size;
                            state.vx *= -currentRestitution;
                        }
                        // Left wall
                        if (state.x < 0) {
                            state.x = 0;
                            state.vx *= -currentRestitution;
                        }
                        // Bottom wall
                        if (state.y + state.size > containerRect.height) {
                            state.y = containerRect.height - state.size;
                            state.vy *= -currentRestitution;
                        }
                        // Top wall
                        if (state.y < 0) {
                            state.y = 0;
                            state.vy *= -currentRestitution;
                        }

                        const newX = (state.x / containerRect.width) * 100;
                        const newY = (state.y / containerRect.height) * 100;
                        
                        if (Math.abs(parseFloat(bubble.style.left) - newX) > 0.01 ||
                            Math.abs(parseFloat(bubble.style.top) - newY) > 0.01) {
                            bubble.style.left = `${newX}%`;
                            bubble.style.top = `${newY}%`;
                        }
                    });

                    // Handle collisions between bubbles
                    const bubbleArray = Array.from(bubbleStates.entries());
                    const bubblesToRemove = new Set();
                    
                    for (let i = 0; i < bubbleArray.length; i++) {
                        const [bubble1, state1] = bubbleArray[i];
                        if (bubblesToRemove.has(bubble1) || bubble1 === draggedBubble) continue;
                        
                        for (let j = i + 1; j < bubbleArray.length; j++) {
                            const [bubble2, state2] = bubbleArray[j];
                            if (bubblesToRemove.has(bubble2) || bubble2 === draggedBubble) continue;
                            
                            // Calculate centers
                            const center1X = state1.x + state1.size / 2;
                            const center1Y = state1.y + state1.size / 2;
                            const center2X = state2.x + state2.size / 2;
                            const center2Y = state2.y + state2.size / 2;
                            
                            // Check collision
                            const dx = center2X - center1X;
                            const dy = center2Y - center1Y;
                            const distance = Math.sqrt(dx * dx + dy * dy);
                            const minDist = (state1.size + state2.size) / 2;

                            if (distance < minDist) {
                                // Check for merge in 'touch' mode
                                if (this.emojiMergeMode === 'touch') {
                                    const emoji1 = bubble1.dataset.emoji;
                                    const emoji2 = bubble2.dataset.emoji;
                                    
                                    if (emoji1 === emoji2) {
                                        // Merge bubbles - calculate new size preserving total area
                                        const area1 = Math.PI * Math.pow(state1.size / 2, 2);
                                        const area2 = Math.PI * Math.pow(state2.size / 2, 2);
                                        const totalArea = area1 + area2;
                                        const newRadius = Math.sqrt(totalArea / Math.PI);
                                        const newSize = Math.min(Math.max(newRadius * 2, 30), 150);
                                        
                                        // Update bubble1 to be the merged bubble
                                        state1.size = newSize;
                                        state1.x = (center1X + center2X) / 2 - newSize / 2;
                                        state1.y = (center1Y + center2Y) / 2 - newSize / 2;
                                        
                                        // Average the velocities
                                        state1.vx = (state1.vx + state2.vx) / 2;
                                        state1.vy = (state1.vy + state2.vy) / 2;
                                        
                                        // Update bubble1 display - no count numbers, just scale size and font
                                        const currentCount = parseInt(bubble1.dataset.count || '1');
                                        const bubble2Count = parseInt(bubble2.dataset.count || '1');
                                        const newCount = currentCount + bubble2Count;
                                        
                                        bubble1.style.width = `${newSize}px`;
                                        bubble1.style.height = `${newSize}px`;
                                        bubble1.style.fontSize = `${newSize * 0.85}px`;
                                        bubble1.innerHTML = emoji1;
                                        bubble1.dataset.count = newCount;
                                        
                                        // Remove bubble2
                                        bubblesToRemove.add(bubble2);
                                        
                                        continue;
                                    }
                                }
                                
                                // Prevent any overlap - immediate and complete separation
                                const nx = dx / distance;
                                const ny = dy / distance;
                                
                                const relativeVelX = state2.vx - state1.vx;
                                const relativeVelY = state2.vy - state1.vy;
                                
                                const relativeSpeed = relativeVelX * nx + relativeVelY * ny;
                                
                                if (relativeSpeed > 0) continue;
                                
                                const overlap = minDist - distance;
                                
                                // Immediately separate bubbles to eliminate all overlap
                                state1.x -= nx * overlap * 0.5;
                                state1.y -= ny * overlap * 0.5;
                                state2.x += nx * overlap * 0.5;
                                state2.y += ny * overlap * 0.5;
                                
                                // Apply repulsion force to prevent future overlaps
                                const repulsionForce = repulsion * 1.5; // Stronger force to maintain separation
                                state1.vx -= nx * repulsionForce;
                                state1.vy -= ny * repulsionForce;
                                state2.vx += nx * repulsionForce;
                                state2.vy += ny * repulsionForce;
                            }
                        }
                    }
                    
                    // Remove merged bubbles
                    bubblesToRemove.forEach(bubble => {
                        bubbleStates.delete(bubble);
                        if (bubble.parentNode) {
                            bubble.parentNode.removeChild(bubble);
                        }
                    });

                    this.bubbleAnimationId = requestAnimationFrame(animate);
                };
                
                this.bubbleAnimationId = requestAnimationFrame(animate);

                // Track mouse position using event delegation
                container.addEventListener('mouseenter', (e) => {
                    const bubble = e.target.closest('.bubble');
                    if (bubble) {
                        const rect = container.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                    }
                });

                container.addEventListener('mousemove', (e) => {
                    const bubble = e.target.closest('.bubble');
                    if (bubble) {
                        const rect = container.getBoundingClientRect();
                        this.mouseX = e.clientX - rect.left;
                        this.mouseY = e.clientY - rect.top;
                    }
                });

                container.addEventListener('mouseout', (e) => {
                    const bubble = e.target.closest('.bubble');
                    const relatedBubble = e.relatedTarget?.closest('.bubble');
                    if (bubble && !relatedBubble) {
                        this.mouseX = null;
                        this.mouseY = null;
                    }
                });

                // Handle window resize
                this.resizeObserver?.disconnect();
                this.resizeObserver = new ResizeObserver(() => {
                    // Recalculate container dimensions
                    const newRect = container.getBoundingClientRect();
                    const scaleX = newRect.width / containerRect.width;
                    const scaleY = newRect.height / containerRect.height;
                    
                    // Scale bubble positions to new container size
                    bubbleStates.forEach((state, bubble) => {
                        state.x *= scaleX;
                        state.y *= scaleY;
                    });
                    
                    // Update container rect reference
                    Object.assign(containerRect, newRect);
                });
            }

            // === RENDER ===
            render() {
                this.updateUndoButton();
                this.checkGoals(); // Always update/check dailies on UI update

                if (this.view === 'timeline') {
                    this.renderTimeline();
                } else if (this.view === 'settings') {
                    this.renderSettings();
                } else if (this.view === 'daily') {
                    this.renderDaily();
                }
            }

            renderTimeline() {
                document.getElementById('mainContainer').innerHTML = `
                    <div class="scroll-container">
                        <div class="date-nav">
                            <div class="date-nav-left">
                                <div class="date-btn" onclick="app.navigateDay(-1)" title="Previous day (Left Arrow)">←</div>
                                <input type="text" 
                                    class="date-input secondary-btn"
                                    value="${this.formatDateInput()}"
                                    maxlength="8"
                                    onkeydown="app.handleDateKeydown(event)"
                                    oninput="app.handleDateInput(event)"
                                    onfocus="app.handleDateFocus(event)"
                                    title="Focus date input (Press 'F')">
                                <div class="date-btn" onclick="app.navigateDay(1)" title="Next day (Right Arrow)">→</div>
                            </div>
                            <div class="date-nav-right">
                                <div onclick="app.jumpToToday()" title="Return to current day">jump to now</div>
                            </div>
                        </div>
                        <div id="goalsSection"></div>
                        <div id="hoursContainer"></div>
                    </div>
                    <div class="scroll-bar ${this.editingHour !== null ? 'hidden' : ''}" id="customScrollBar"></div>
                `;

                const container = document.querySelector('.main-container');
                container.addEventListener('scroll', this.handleScroll.bind(this));
                if (this.timelineScrollPosition > 0) {
                    container.scrollTop = this.timelineScrollPosition;
                }

                // Set up swipe events for the main container
                this.setupSwipeEvents(container);

                // Custom scrollbar logic
                const scrollBar = document.getElementById('customScrollBar');
                let isDragging = false;
                let startY = 0;
                let startScroll = 0;

                scrollBar.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    startY = e.clientY;
                    startScroll = container.scrollTop;
                    scrollBar.classList.add('dragging');
                    document.body.style.userSelect = 'none';
                });

                document.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    const deltaY = e.clientY - startY;
                    container.scrollTop = startScroll - deltaY * 2; // inverted direction, 2x impact
                });

                document.addEventListener('mouseup', () => {
                    if (isDragging) {
                        isDragging = false;
                        scrollBar.classList.remove('dragging');
                        document.body.style.userSelect = '';
                    }
                });

                // Double click to jump to now
                scrollBar.addEventListener('dblclick', () => {
                    app.jumpToToday();
                });

                this.renderGoals();
                this.renderHours();
            }

            renderGoals() {
                const goalsSection = document.getElementById('goalsSection');
                if (!goalsSection) return;
                
                const goalChecks = this.checkGoals();

                if (this.goals.length > 0 && this.showGoalsInTimeline) {
                    goalsSection.innerHTML = `
                        <div class="goals-section">
                            ${goalChecks.map(goal => `
                                <div class="goal-item ${goal.met ? 'passed' : 'failed'}">
                                    <span class="goal-text">${this.formatGoalText(goal)}</span>
                                </div>
                            `).join('')}
                        </div>
                    `;
                } else if (this.goals.length === 0 && this.showGoalsInTimeline) {
                    goalsSection.innerHTML = '<div class="no-goals">no dailies set - add in settings</div>';
                } else {
                    goalsSection.innerHTML = '';
                }
            }

            renderHours() {
                this.saveData();
                const hoursContainer = document.getElementById('hoursContainer');
                if (!hoursContainer) return;
                
                hoursContainer.innerHTML = `
                    <div class="hours-container">
                        ${this.hours.map(hour => {
                            const entry = this.entries[hour] || { emojis: [], text: '' };
                            const isCurrent = this.isCurrentHour(hour);
                            const isEditing = this.editingHour === hour;
                            const hourFill = this.getHourFill(hour);
                            // Show all emojis if there's no text, otherwise limit to 6
                            const emojis = (entry.emojis || []).slice(0, entry.text ? 6 : undefined);

                            return `
                                <div class="hour-row">
                                    ${isEditing ? `
                                        <div class="emoji-picker below">
                                            ${this.emojis.map(emoji => `
                                                <button class="emoji-btn ${entry.emojis?.includes(emoji) ? 'selected' : ''}"
                                                        onclick="app.toggleEmoji('${emoji}')">
                                                    ${emoji}
                                                </button>
                                            `).join('')}
                                        </div>
                                    ` : ''}
                                    
                                    <div class="hour-entry ${isCurrent ? 'current' : ''} ${isEditing ? 'editing' : ''}"
                                         data-hour="${hour}"
                                         onclick="app.editHour(${hour})">
                                        ${hourFill > 0 ? `<div class="hour-fill ${!entry.text && !entry.emojis?.length ? 'empty' : ''}" style="width: ${hourFill}%;"></div>` : ''}
                                        <div class="hour-content">
                                            <span class="hour-time">${this.formatHour(hour)}</span>
                                            <div class="hour-emojis">
                                                ${emojis.map(emoji => `<span class="emoji">${emoji}</span>`).join('')}
                                            </div>
                                            ${isEditing ? `
                                                <div class="hour-input-container">
                                                    <textarea class="hour-input"
                                                           placeholder="${this.isFutureDate() ? 'Plan ahead...' : this.isPastDate() ? 'Remember...' : 'What happened?'}"
                                                           oninput="app.updateText(this.value)"
                                                           onkeydown="app.handleHourInputKeydown(event, ${hour})"
                                                           onclick="event.stopPropagation()">${entry.text}</textarea>
                                                    <button class="clear-btn" onclick="event.stopPropagation(); app.clearEntry(${hour})">×</button>
                                                </div>
                                            ` : `<span class="hour-text">${entry.text.replace(/\n/g, '<br>')}</span>`}
                                        </div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        ${this.editingHour !== null ? '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 500;" onclick="app.finishEditing()"></div>' : ''}
                    </div>
                `;
                this.attachCopyPasteEvents();
            }

            renderSettings() {
                document.getElementById('mainContainer').innerHTML = `
                    <div class="settings-container">
                        <div class="setting-group">
                            <label class="setting-label">Available Emojis</label>
                            <textarea class="setting-input emoji-input" 
                                onfocus="app.openEmojiModal(this)"
                                onblur="app.handleEmojiBlur(this)"
                            >${this.emojiDescriptions || this.emojis.join('')}</textarea>
                            
                        </div>
                        
                            
                        <div class="setting-group">
                            <div id="goalsList"></div>
                            <div style="display: flex; align-items: center; justify-content: space-between; gap: 16px; margin-top: 12px;">
                                <button class="add-goal-btn" onclick="app.addGoal()">+ Add Daily</button>
                                <label class="checkbox-label" style="margin-bottom: 0; background-color: transparent;">
                                    <input type="checkbox" class="checkbox" ${this.showGoalsInTimeline ? 'checked' : ''} onchange="app.showGoalsInTimeline = this.checked; app.saveData()">
                                    <span>Show in timeline</span>
                                </label>
                            </div>
                        </div>

                        <div class="setting-group">
                            <label class="setting-label">Start Hour</label>
                            <select class="setting-input" onchange="app.startHour = parseInt(this.value); app.saveData()">
                                ${Array.from({length: 24}, (_, i) => `
                                    <option value="${i}" ${i === this.startHour ? 'selected' : ''}>
                                        ${this.formatHour(i)}:00
                                    </option>
                                `).join('')}
                            </select>
                        </div>
                        
                        <div class="setting-group">
                            <div class="export-section">
                                <button class="export-toggle" onclick="this.nextElementSibling.style.display = this.nextElementSibling.style.display === 'none' ? 'block' : 'none'; this.querySelector('.export-arrow').classList.toggle('open')">
                                    Export/Import Data
                                    <span class="export-arrow">▼</span>
                                </button>
                                <div class="export-content" style="display: none;">
                                    <button class="export-btn" onclick="app.exportAllToJSON()" style="margin-bottom: 12px;">
                                        Export All Data as JSON
                                    </button>
                                    <div class="import-section">
                                        <input type="file" class="import-input" accept=".json" 
                                               onchange="if(this.files.length) app.importFromJSONFile(this.files[0])">
                                    </div>
                                    <div class="export-help">
                                        Export creates a single JSON file with all your data, settings, and dailies.
                                        <br>• Import supports both new and legacy formats
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        ${this.editingGoal !== null ? `
                            <div class="modal-overlay" onclick="if(event.target === this) { app.editingGoal = null; app.renderSettings(); }">
                                <div class="modal" onclick="event.stopPropagation();">
                                    ${this.goals.filter(g => g.id === this.editingGoal).map(goal => {
                                        const selectedEmojis = Array.isArray(goal.emojis) ? goal.emojis : [goal.emoji];
                                        return `
                                            <div class="goal-editor-section">
                                                <div class="goal-emoji-grid">
                                                    ${this.emojis.map(emoji => `
                                                        <button class="goal-emoji-btn ${selectedEmojis.includes(emoji) ? 'selected' : ''}"
                                                                onclick="app.toggleGoalEmoji(${goal.id}, '${emoji}')">
                                                            ${emoji}
                                                        </button>
                                                    `).join('')}
                                                </div>
                                                <div class="operator-value-group">
                                                    <button class="goal-action-btn goal-toggle" onclick="app.toggleGoalNegation(${goal.id})">
                                                        ${goal.not ? 'is not' : 'is'}
                                                    </button>
                                                    <button class="goal-operator-btn goal-toggle" onclick="app.cycleOperator(${goal.id})">
                                                        ${goal.operator.replace('_', ' ')}
                                                    </button>
                                                    <input type="number" 
                                                           class="goal-value-input" 
                                                           value="${goal.value}" 
                                                           min="0" 
                                                           max="23"
                                                           onclick="event.stopPropagation()"
                                                           onblur="app.updateGoal(${goal.id}, { value: parseInt(this.value) || 0 })">
                                                    <span class="goal-times-text">
                                                        ${goal.operator.includes('than') ? 'times' : ''}
                                                    </span>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                        ` : ''}
                    </div>
                `;

                this.renderGoalsList();
            }

            renderGoalsList() {
                const goalsList = document.getElementById('goalsList');
                if (!goalsList) return;
                goalsList.innerHTML = "<h3>Dailies</h3>" + this.goals.map(goal => {
                    const isEditing = this.editingGoal === goal.id;
                    return `
                        <div class="goal-row">
                            <div class="goal-summary ${isEditing ? 'editing' : ''}" onclick="app.editGoal(${goal.id})">
                               <span class="goal-text-display">${this.formatGoalText(goal)}</span>
                                <button class="remove-goal-btn" onclick="event.stopPropagation(); app.removeGoal(${goal.id})">×</button>
                            </div>
                        </div>
                    `;
                }).join('');
            }

            extractEmojis(text) {
                // Split text into proper grapheme clusters using Intl.Segmenter
                const segments = [...new Intl.Segmenter().segment(text)]
                    .map(x => x.segment)
                    .filter(segment => segment.match(/\p{Emoji}/u));
                
                // Remove duplicates
                return Array.from(new Set(segments));
            }

            openEmojiModal(textarea) {
                // Prevent the blur handler from closing modal immediately
                textarea._isOpeningModal = true;
                
                // Create modal overlay
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay emoji-modal-overlay';
                overlay.onclick = (e) => {
                    if (e.target === overlay) {
                        this.closeEmojiModal(textarea);
                    }
                };
                
                // Create modal container
                const modal = document.createElement('div');
                modal.className = 'modal emoji-modal';
                modal.style.width = 'min(90%, 800px)';
                modal.style.height = '80vh';
                modal.onclick = (e) => e.stopPropagation();
                
                // Create the textarea clone
                const modalTextarea = document.createElement('textarea');
                modalTextarea.className = 'setting-input emoji-input';
                modalTextarea.style.width = '100%';
                modalTextarea.style.height = 'calc(100% - 20px)';
                modalTextarea.style.resize = 'none';
                modalTextarea.style.border = 'none';
                modalTextarea.style.outline = 'none';
                modalTextarea.style.fontSize = '1.1em';
                modalTextarea.style.padding = '20px';
                modalTextarea.value = textarea.value;
                
                // Set up blur handler for the modal textarea
                modalTextarea.onblur = () => {
                    setTimeout(() => {
                        if (!modal.contains(document.activeElement)) {
                            this.closeEmojiModal(textarea);
                        }
                    }, 100);
                };
                
                modal.appendChild(modalTextarea);
                overlay.appendChild(modal);
                document.body.appendChild(overlay);
                
                // Store reference for cleanup
                textarea._emojiModalOverlay = overlay;
                textarea._emojiModalTextarea = modalTextarea;
                
                // Focus the modal textarea after a brief delay
                setTimeout(() => {
                    modalTextarea.focus();
                    textarea._isOpeningModal = false;
                }, 100);
            }
            
            handleEmojiBlur(textarea) {
                // Don't close if we're in the process of opening the modal
                if (textarea._isOpeningModal || textarea._emojiModalOverlay) {
                    return;
                }
                // Handle normal blur (save the content)
                this.handleEmojiInput(textarea.value);
            }
            
            closeEmojiModal(textarea) {
                const overlay = textarea._emojiModalOverlay;
                const modalTextarea = textarea._emojiModalTextarea;
                
                if (overlay && modalTextarea) {
                    // Update the original textarea value
                    textarea.value = modalTextarea.value;
                    
                    // Handle the emoji input
                    this.handleEmojiInput(modalTextarea.value);
                    
                    // Remove the modal
                    document.body.removeChild(overlay);
                    
                    // Clean up references
                    delete textarea._emojiModalOverlay;
                    delete textarea._emojiModalTextarea;
                }
            }

            handleEmojiInput(value) {
                // Store the full text input
                this.emojiDescriptions = value;
                
                // Extract and update emojis list
                const extractedEmojis = this.extractEmojis(value);
                if (extractedEmojis.length > 0) {
                    // Check if any existing emojis are compound (contain ZWJ) and might have been split during extraction
                    const preservedCompoundEmojis = this.emojis.filter(existingEmoji => {
                        // Keep compound emojis that contain ZWJ (Zero Width Joiner) or variation selectors
                        const isCompound = existingEmoji.includes('\u200D') || existingEmoji.includes('\uFE0F');
                        // Only preserve if it's not already in the extracted list
                        return isCompound && !extractedEmojis.includes(existingEmoji);
                    });
                    
                    // Combine extracted emojis with preserved compound ones, removing duplicates
                    this.emojis = [...new Set([...extractedEmojis, ...preservedCompoundEmojis])];
                } else {
                    this.emojis = extractedEmojis;
                }
                
                this.saveData();
            }
            

            toggleGoalEmoji(goalId, emoji) {
                const goal = this.goals.find(g => g.id === goalId);
                let emojis = Array.isArray(goal.emojis) ? [...goal.emojis] : [goal.emoji];
                if (emojis.includes(emoji)) {
                    emojis = emojis.filter(e => e !== emoji);
                } else {
                    emojis.push(emoji);
                }
                if (emojis.length === 0) emojis = [emoji];
                this.updateGoal(goalId, { emojis });
            }
            
                toggleGoalNegation(goalId) {
                    const goal = this.goals.find(g => g.id === goalId);
                    this.updateGoal(goalId, { not: !goal.not });
                }
            

            renderDaily() {
                const goalChecks = this.checkGoals();
                const isToday = this.isCurrentDate();
                const wipeLabel = isToday ? 'clear today' : 'clear day';
                const copyLabel = isToday ? 'copy today' : 'share this day';
                
                // Get wipe button text based on confirmation step (simplified to 2 steps)
                let wipeButtonText;
                if (this.wipeConfirmationStep === 0) {
                    wipeButtonText = `🗑️ ${wipeLabel}`;
                } else if (this.wipeConfirmationStep === 1) {
                    const dayText = isToday ? 'today' : 'day';
                    wipeButtonText = `⚠️ delete all entries of ${dayText}`;
                } else {
                    wipeButtonText = '🚨 are you sure?';
                }
                
                document.getElementById('mainContainer').innerHTML = `
                    <div class="daily-container" onclick="app.resetWipeConfirmation()">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; gap: 8px;">
                            <button class="jump-btn ${this.wipeConfirmationStep > 0 ? 'wipe-confirmation' : ''}" id="wipeDayBtn" onclick="event.stopPropagation(); app.handleWipeConfirmation();">${wipeButtonText}</button>
                            <button class="jump-btn" 
                                    onclick="event.stopPropagation(); app.cycleMergeMode()" 
                                    title="Toggle emoji merge mode">${this.getMergeModeLabel()}</button>
                            <button class="jump-btn" id="copyDayBtn" onclick="app.exportCurrentDayTextWithAnimation()">📋 ${copyLabel}</button>
                        </div>
                        
                        <div class="bubbles-container">
                            ${(() => {
                                const processedBubbles = this.processBubblesForMerging();
                                
                                return processedBubbles.map(bubble => {
                                    // Always show just the emoji, no count numbers
                                    const displayText = bubble.emoji;
                                    // Scale font size proportionally with bubble size (85% of bubble size)
                                    const fontSize = bubble.size * 0.85;
                                    
                                    return `
                                        <div class="bubble" data-emoji="${bubble.emoji}" data-id="${bubble.id}" data-count="${bubble.count || 1}" style="
                                            left: ${bubble.x}%; 
                                            top: ${bubble.y}%; 
                                            width: ${bubble.size}px; 
                                            height: ${bubble.size}px; 
                                            font-size: ${fontSize}px;
                                            transition: none;
                                            border-radius: 50%;
                                            display: flex;
                                            align-items: center;
                                            justify-content: center;
                                            background-color: var(--color-bg-dark);
                                            line-height: 1;
                                        ">
                                            ${displayText}
                                        </div>
                                    `;
                                }).join('');
                            })()}
                        </div>

                        <h3>Dailies</h3>
                        <div class="dailies-section">
                            ${goalChecks.map(goal => `
                                <div class="goal-item ${goal.met ? 'passed' : 'failed'}" style="margin-bottom:8px;">
                                    <span class="goal-text">${this.formatGoalText(goal)}</span>
                                </div>
                            `).join('')}
                            ${this.goals.length === 0 ? '<p class="no-goals-daily">No dailies set</p>' : ''}
                        </div>
                    </div>
                `;
                
                // Set up swipe events for the daily container
                const dailyContainer = document.querySelector('.daily-container');
                this.setupSwipeEvents(dailyContainer);
                
                this.startBubbleAnimation();
            }
        }

        const app = new HourliesApp();
    </script>
</body>
</html>
